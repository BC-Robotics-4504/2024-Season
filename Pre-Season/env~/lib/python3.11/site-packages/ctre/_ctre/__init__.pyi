from __future__ import annotations
import ctre._ctre
import typing
import wpilib._wpilib
import wpilib.interfaces._interfaces
import wpiutil._wpiutil

__all__ = [
    "BaseMotorController",
    "BaseMotorControllerConfiguration",
    "BaseMotorControllerUtil",
    "BasePIDSetConfiguration",
    "BaseTalon",
    "BaseTalonConfigUtil",
    "BaseTalonConfiguration",
    "BaseTalonPIDSetConfigUtil",
    "BaseTalonPIDSetConfiguration",
    "BufferedTrajectoryPointStream",
    "CANBusAddressable",
    "CANifier",
    "CANifierConfigUtils",
    "CANifierConfiguration",
    "CANifierControlFrame",
    "CANifierFaults",
    "CANifierStatusFrame",
    "CANifierStickyFaults",
    "CANifierVelocityMeasPeriod",
    "ControlFrame",
    "ControlFrameEnhanced",
    "ControlMode",
    "CustomParamConfigUtil",
    "CustomParamConfiguration",
    "DemandType",
    "ErrorCode",
    "Faults",
    "FeedbackDevice",
    "FilterConfigUtil",
    "FilterConfiguration",
    "FollowerType",
    "IFollower",
    "IGadgeteerUartClient",
    "IInvertable",
    "ILoopable",
    "IMotorController",
    "IMotorControllerEnhanced",
    "IOutputSignal",
    "IProcessable",
    "InvertType",
    "LimitSwitchNormal",
    "LimitSwitchRoutines",
    "LimitSwitchSource",
    "MotionProfileStatus",
    "MotorCommutation",
    "MovingAverage",
    "NeutralMode",
    "Orchestra",
    "ParamEnum",
    "RemoteFeedbackDevice",
    "RemoteLimitSwitchSource",
    "RemoteSensorSource",
    "SensorCollection",
    "SensorTerm",
    "SetValueMotionProfile",
    "SlotConfigUtil",
    "SlotConfiguration",
    "StatorCurrentLimitConfiguration",
    "StatusFrame",
    "StatusFrameEnhanced",
    "StatusFrameRoutines",
    "StickyFaults",
    "SupplyCurrentLimitConfiguration",
    "TalonFX",
    "TalonFXConfigUtil",
    "TalonFXConfiguration",
    "TalonFXControlMode",
    "TalonFXFeedbackDevice",
    "TalonFXInvertType",
    "TalonFXPIDSetConfiguration",
    "TalonFXSensorCollection",
    "TalonFXSimCollection",
    "TalonSRX",
    "TalonSRXConfigUtil",
    "TalonSRXConfiguration",
    "TalonSRXControlMode",
    "TalonSRXFeedbackDevice",
    "TalonSRXPIDSetConfiguration",
    "TalonSRXSimCollection",
    "TrajectoryPoint",
    "Unmanaged",
    "VelocityMeasPeriod",
    "VictorConfigUtil",
    "VictorSPX",
    "VictorSPXConfiguration",
    "VictorSPXControlMode",
    "VictorSPXPIDSetConfigUtil",
    "VictorSPXPIDSetConfiguration",
    "VictorSPXSimCollection",
    "WPI_BaseMotorController",
    "WPI_TalonFX",
    "WPI_TalonSRX",
    "WPI_VictorSPX",
    "led",
    "sensors"
]


class IFollower():
    """
    Interface for followers
    """
    def __init__(self) -> None: ...
    def follow(self, masterToFollow: IMotorController) -> None: 
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.

        :param masterToFollow: *                                                Motor Controller object to follow.
        """
    def valueUpdated(self) -> None: 
        """
        When master makes a device, this routine is called to signal the update.
        """
    pass
class CustomParamConfiguration():
    """
    Configurables for any custom param configs
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of currently selected configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: string representation fo currently selected configs
        """
    @property
    def customParam0(self) -> int:
        """
        Custom Param 0

        :type: int
        """
    @customParam0.setter
    def customParam0(self, arg0: int) -> None:
        """
        Custom Param 0
        """
    @property
    def customParam1(self) -> int:
        """
        Custom Param 1

        :type: int
        """
    @customParam1.setter
    def customParam1(self, arg0: int) -> None:
        """
        Custom Param 1
        """
    @property
    def enableOptimizations(self) -> bool:
        """
        Enable optimizations for ConfigAll (defaults true)

        :type: bool
        """
    @enableOptimizations.setter
    def enableOptimizations(self, arg0: bool) -> None:
        """
        Enable optimizations for ConfigAll (defaults true)
        """
    pass
class CustomParamConfigUtil():
    """
    Util class to help custom configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def customParam0Different(settings: CustomParamConfiguration) -> bool: 
        """
        :param settings: Settings to compare against

        :returns: Whether CustomParam0 is different
        """
    @staticmethod
    def customParam1Different(settings: CustomParamConfiguration) -> bool: 
        """
        :param settings: Settings to compare against

        :returns: Whether CustomParam1 is different
        """
    pass
class BasePIDSetConfiguration():
    """
    Base set of configurables related to PID
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @property
    def selectedFeedbackCoefficient(self) -> float:
        """
        Feedback coefficient of selected sensor

        :type: float
        """
    @selectedFeedbackCoefficient.setter
    def selectedFeedbackCoefficient(self, arg0: float) -> None:
        """
        Feedback coefficient of selected sensor
        """
    pass
class IMotorController(IFollower):
    """
    Interface for motor controllers
    """
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode: 
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.

        :param periodMs: The transmit period in ms.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode: 
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).

        :returns: Error Code generated by function. 0 indicates no error
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears all sticky faults.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the allowable closed-loop error in the given parameter slot.

        :param slotIdx:                 Parameter slot for the constant.
        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
        :param timeoutMs:               Timeout value in ms. If nonzero, function will wait for
                                        config success and report an error if it times out.
                                        If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Polarity of the Auxiliary PID (PID1).

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :param invert:    If true, use inverted PID1 output polarity.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.

        :param slotIdx:    Parameter slot for the constant.
        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                           *                                            the magnitude will apply in both forward and reverse directions.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.

        :param slotIdx:    Parameter slot for the constant.
        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                           *                                            1 ms, maximum of 64 ms.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the closed-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeout: int) -> ErrorCode: 
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.

        Alternatively you can use the configAllSettings routine.

        :param timeout: Timeout value in ms. Function will generate error if config is
                        not successful within timeout.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)

        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.

        :param feedbackNotContinuous: True to disable the overflow tracking.
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit enable.

        :param enable:    Forward Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit threhold.

        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter.

        :param paramIndex: Index of custom parameter [0,1].
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Value of the custom param.
        """
    def configGetParameter(self, paramEnum: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter.

        :param paramEnum: Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Value of parameter.
        """
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.

        :param limitSwitchDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                      Timeout value in ms. If nonzero, function will wait for
                                               config success and report an error if it times out.
                                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the maximum integral accumulator in the given parameter slot.

        :param slotIdx:   Parameter slot for the constant.
        :param iaccum:    Value of the maximum integral accumulator (closed loop error
                          units X 1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.

        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                          second).
        :param timeoutMs:                 Timeout value in ms. If nonzero, function will wait for config
                                          success and report an error if it times out. If zero, no
                                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.

        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for config
                                    success and report an error if it times out. If zero, no
                                    blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).

        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.

        :param baseTrajDurationMs: The base duration time of every trajectory point.
                                   This is summed with the trajectory points unique timeDur.
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int) -> ErrorCode: 
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.

        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for config
                              success and report an error if it times out. If zero, no
                              blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the output deadband percentage.

        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                                Pass 0.04 for 4% (factory default).
        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [0,+1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [-1,0]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the open-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward peak output percentage.

        :param percentOut: Desired peak output percentage. [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse peak output percentage.

        :param percentOut: Desired peak output percentage.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).

        :param pulseWidthPeriod_EdgesPerRot: edges per rotation
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).

        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg
        :param timeoutMs:                       Timeout value in ms. If nonzero, function will wait for
                                                config success and report an error if it times out.
                                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: sensors.CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param deviceID:           The device ID of the remote sensor device.
        :param remoteSensorSource: The remote sensor device and signal type to bind.
        :param remoteOrdinal:      0 for configuring Remote Sensor 0,
                                   1 for configuring Remote Sensor 1
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param canCoderRef:   CANCoder device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param talonRef:      Talon device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configRemoteFeedbackFilter(self, talonRef: BaseTalon, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.

        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral
        :param timeoutMs:                                 Timeout value in ms. If nonzero, function will wait for
                                                          config success and report an error if it times out.
                                                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit enable.

        :param enable:    Reverse Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit threshold.

        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.

        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.

        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                            *                                           Resolution is 1/(2^16).  Cannot be 0.
        :param pidIdx:      0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.

        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.

        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.

        :param softLimitDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Voltage Compensation saturation voltage.

        :param voltage:   This is the max voltage to apply to the hbridge when voltage
                          compensation is enabled.  For example, if 10 (volts) is specified
                          and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                          then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the voltage measurement filter.

        :param filterWindowSamples: Number of samples in the rolling average of voltage
                                    measurement.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :param slotIdx:   Parameter slot for the constant.
        :param izone:     Value of the Integral Zone constant (closed loop error units X
                          1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'D' constant in the given parameter slot.

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the D constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'F' constant in the given parameter slot.

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the F constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the I constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the P constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enableVoltageCompensation(self, enable: bool) -> None: 
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.

        Be sure to configure the saturation voltage before enabling this.

        :param enable: Enable state of voltage compensation.
        """
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory target position for using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory target velocity for using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int: 
        """
        :returns: BaseID of device
        """
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> float: 
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.

        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).

        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).

        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.

        See Phoenix-Documentation information on units.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float: 
        """
        Gets the current target of a given closed loop.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode: 
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int: 
        """
        Returns the Device ID

        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float: 
        """
        Gets the derivative of the closed-loop error.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode: 
        """
        Polls the various fault flags.

        :param toFill: Caller's object to fill with latest fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float: 
        """
        Gets the iaccum value.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool: 
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode: 
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.

        The members are filled, as follows...

        *       topBufferRem:   The available empty slots in the trajectory buffer.
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the
        low-level buffer, allowing the motor controller to act on them.

        *       topBufferRem: The number of points in the top trajectory buffer.

        *       btmBufferCnt: The number of points in the low level controller buffer.

        *       hasUnderrun:    Set if isUnderrun ever gets set.
        Can be manually cleared by clearMotionProfileHasUnderrun() or automatically cleared by startMotionProfile().

        *       isUnderrun:             This is set if controller needs to shift a point from its buffer into
        *                                       the active trajectory point however
        *                                       the buffer is empty.
        *                                       This gets cleared automatically when is resolved.

        *       activePointValid:       True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.

        *       isLast: is set/cleared based on the MP executer's current
        trajectory point's IsLast value.  This assumes
        IsLast was set when PushMotionProfileTrajectory
        was used to insert the currently processed trajectory
        point.

        *       profileSlotSelect: The currently processed trajectory point's
        selected slot.  This can differ in the currently selected slot used
        for Position and Velocity servo modes

        *       outputEnable:           The current output mode of the motion profile
        *                                               executer (disabled, enabled, or hold).  When changing the set()
        *                                               value in MP mode, it's important to check this signal to
        *                                               confirm the change takes effect before interacting with the top buffer.

        :param statusToFill: Caller supplied object to fill.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int: 
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float: 
        """
        Gets the output percentage of the motor controller.

        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float: 
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> float: 
        """
        Get the selected sensor position (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
                       Phoenix-Documentation for how to interpret.

        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> float: 
        """
        Get the selected sensor velocity.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode: 
        """
        Polls the various sticky fault flags.

        :param toFill: Caller's object to fill with latest sticky fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float: 
        """
        Gets the temperature of the motor controller.

        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool: 
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool: 
        """
        Returns the enable state of Voltage Compensation that the caller has set.

        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None: 
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None: 
        """
        Sets the enable state for limit switches.

        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None: 
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.

        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None: 
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).

        targPos:  servo position in sensor units.
        *               targVel:  velocity to feed-forward in sensor units
        per 100ms.
        profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
        *                                                  as the Kv constant for velocity feed-forward. Typically this is hardcoded
        *                                                  to the a particular slot, but you are free gain schedule if need be.
        *                                                  Choose from [0,3]
        *               profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
        *                                                  This only has impact during MotionProfileArc Control mode.
        *                                                  Choose from [0,1].
        isLastPoint  set to nonzero to signal motor controller to keep processing this
        trajectory point, instead of jumping to the next one
        when timeDurMs expires.  Otherwise MP executer will
        eventually see an empty buffer after the last point
        expires, causing it to assert the IsUnderRun flag.
        However this may be desired if calling application
        never wants to terminate the MP.
        *               zeroPos  set to nonzero to signal motor controller to "zero" the selected
        position sensor before executing this trajectory point.
        Typically the first point should have this set only thus
        allowing the remainder of the MP positions to be relative to
        zero.
        *               timeDur Duration to apply this trajectory pt.
        This time unit is ADDED to the exising base time set by
        configMotionProfileTrajectoryPeriod().

        :param trajPt: to push into buffer.
                       The members should be filled in with these values...

        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode: 
        """
        Selects which profile slot to use for closed-loop control.

        :param slotIdx: Profile slot to select.
        :param pidIdx:  0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, Mode: ControlMode, demand: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        *       Standard Driving Example:
        *       _talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *       _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        :param Mode:   The output mode to apply.
                       In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                       In Current mode, output value is in amperes.
                       In Velocity mode, output value is in position change / 100ms.
                       In Position mode, output value is in encoder ticks or an analog value,
                       depending on the sensor.
                       In Follower mode, the output value is the integer device ID of the talon to
                       duplicate.
        :param demand: The setpoint value, as described above.

        Arcade Drive Example:
        *               _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.  Units match the set mode.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.

        :param iaccum:    Value to set for the integral accumulator (closed loop error
                          units X 1ms).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller.

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.

        :param invert: Invert state to set.

        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setNeutralMode(self, neutralMode: NeutralMode) -> None: 
        """
        Sets the mode of operation during neutral throttle output.

        :param neutralMode: The desired mode of operation when the Controller output
                            throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: float, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets the sensor position to the given value.

        :param sensorPos: Position to set for the selected sensor (in raw sensor units).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None: 
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.

        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    pass
class BaseTalonConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def diff0TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def diff1TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def sum0TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def sum1TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    pass
class BaseMotorControllerConfiguration(CustomParamConfiguration):
    """
    Configurables available to base motor controllers
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @property
    def auxPIDPolarity(self) -> bool:
        """
        PID polarity inversion

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :type: bool
        """
    @auxPIDPolarity.setter
    def auxPIDPolarity(self, arg0: bool) -> None:
        """
        PID polarity inversion

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,
        """
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Clear the position on forward limit

        :type: bool
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        """
        Clear the position on forward limit
        """
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Clear the position on reverse limit

        :type: bool
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        """
        Clear the position on reverse limit
        """
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Clear the position on index

        :type: bool
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        """
        Clear the position on index
        """
    @property
    def closedloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in closed loop

        :type: float
        """
    @closedloopRamp.setter
    def closedloopRamp(self, arg0: float) -> None:
        """
        Seconds to go from 0 to full in closed loop
        """
    @property
    def feedbackNotContinuous(self) -> bool:
        """
        Determine whether feedback sensor is continuous or not

        :type: bool
        """
    @feedbackNotContinuous.setter
    def feedbackNotContinuous(self, arg0: bool) -> None:
        """
        Determine whether feedback sensor is continuous or not
        """
    @property
    def forwardSoftLimitEnable(self) -> bool:
        """
        Enable forward soft limit

        :type: bool
        """
    @forwardSoftLimitEnable.setter
    def forwardSoftLimitEnable(self, arg0: bool) -> None:
        """
        Enable forward soft limit
        """
    @property
    def forwardSoftLimitThreshold(self) -> float:
        """
        Threshold for soft limits in forward direction (in raw sensor units)

        :type: float
        """
    @forwardSoftLimitThreshold.setter
    def forwardSoftLimitThreshold(self, arg0: float) -> None:
        """
        Threshold for soft limits in forward direction (in raw sensor units)
        """
    @property
    def limitSwitchDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote limit switch is lost on CAN bus

        :type: bool
        """
    @limitSwitchDisableNeutralOnLOS.setter
    def limitSwitchDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote limit switch is lost on CAN bus
        """
    @property
    def motionAcceleration(self) -> float:
        """
        Motion Magic acceleration in (raw sensor units per 100 ms) per second.

        :type: float
        """
    @motionAcceleration.setter
    def motionAcceleration(self, arg0: float) -> None:
        """
        Motion Magic acceleration in (raw sensor units per 100 ms) per second.
        """
    @property
    def motionCruiseVelocity(self) -> float:
        """
        Motion Magic cruise velocity in raw sensor units per 100 ms.

        :type: float
        """
    @motionCruiseVelocity.setter
    def motionCruiseVelocity(self, arg0: float) -> None:
        """
        Motion Magic cruise velocity in raw sensor units per 100 ms.
        """
    @property
    def motionCurveStrength(self) -> int:
        """
        Zero to use trapezoidal motion during motion magic.  [1,8] for S-Curve, higher value for greater smoothing.

        :type: int
        """
    @motionCurveStrength.setter
    def motionCurveStrength(self, arg0: int) -> None:
        """
        Zero to use trapezoidal motion during motion magic.  [1,8] for S-Curve, higher value for greater smoothing.
        """
    @property
    def motionProfileTrajectoryPeriod(self) -> int:
        """
        Motion profile base trajectory period in milliseconds.

        The period specified in a trajectory point will be
        added on to this value

        :type: int
        """
    @motionProfileTrajectoryPeriod.setter
    def motionProfileTrajectoryPeriod(self, arg0: int) -> None:
        """
        Motion profile base trajectory period in milliseconds.

        The period specified in a trajectory point will be
        added on to this value
        """
    @property
    def neutralDeadband(self) -> float:
        """
        Neutral deadband [0.001, 0.25]

        :type: float
        """
    @neutralDeadband.setter
    def neutralDeadband(self, arg0: float) -> None:
        """
        Neutral deadband [0.001, 0.25]
        """
    @property
    def nominalOutputForward(self) -> float:
        """
        Nominal/Minimum output in forward direction [0,1]

        :type: float
        """
    @nominalOutputForward.setter
    def nominalOutputForward(self, arg0: float) -> None:
        """
        Nominal/Minimum output in forward direction [0,1]
        """
    @property
    def nominalOutputReverse(self) -> float:
        """
        Nominal/Minimum output in reverse direction [-1,0]

        :type: float
        """
    @nominalOutputReverse.setter
    def nominalOutputReverse(self, arg0: float) -> None:
        """
        Nominal/Minimum output in reverse direction [-1,0]
        """
    @property
    def openloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in open loop

        :type: float
        """
    @openloopRamp.setter
    def openloopRamp(self, arg0: float) -> None:
        """
        Seconds to go from 0 to full in open loop
        """
    @property
    def peakOutputForward(self) -> float:
        """
        Peak output in forward direction [0,1]

        :type: float
        """
    @peakOutputForward.setter
    def peakOutputForward(self, arg0: float) -> None:
        """
        Peak output in forward direction [0,1]
        """
    @property
    def peakOutputReverse(self) -> float:
        """
        Peak output in reverse direction [-1,0]

        :type: float
        """
    @peakOutputReverse.setter
    def peakOutputReverse(self, arg0: float) -> None:
        """
        Peak output in reverse direction [-1,0]
        """
    @property
    def pulseWidthPeriod_EdgesPerRot(self) -> int:
        """
        Number of edges per rotation for a tachometer sensor

        :type: int
        """
    @pulseWidthPeriod_EdgesPerRot.setter
    def pulseWidthPeriod_EdgesPerRot(self, arg0: int) -> None:
        """
        Number of edges per rotation for a tachometer sensor
        """
    @property
    def pulseWidthPeriod_FilterWindowSz(self) -> int:
        """
        Desired window size for a tachometer sensor

        :type: int
        """
    @pulseWidthPeriod_FilterWindowSz.setter
    def pulseWidthPeriod_FilterWindowSz(self, arg0: int) -> None:
        """
        Desired window size for a tachometer sensor
        """
    @property
    def remoteFilter0(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 0

        :type: FilterConfiguration
        """
    @remoteFilter0.setter
    def remoteFilter0(self, arg0: FilterConfiguration) -> None:
        """
        Configuration for RemoteFilter 0
        """
    @property
    def remoteFilter1(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 1

        :type: FilterConfiguration
        """
    @remoteFilter1.setter
    def remoteFilter1(self, arg0: FilterConfiguration) -> None:
        """
        Configuration for RemoteFilter 1
        """
    @property
    def remoteSensorClosedLoopDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote sensor is lost on CAN bus

        :type: bool
        """
    @remoteSensorClosedLoopDisableNeutralOnLOS.setter
    def remoteSensorClosedLoopDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote sensor is lost on CAN bus
        """
    @property
    def reverseSoftLimitEnable(self) -> bool:
        """
        Enable reverse soft limit

        :type: bool
        """
    @reverseSoftLimitEnable.setter
    def reverseSoftLimitEnable(self, arg0: bool) -> None:
        """
        Enable reverse soft limit
        """
    @property
    def reverseSoftLimitThreshold(self) -> float:
        """
        Threshold for soft limits in reverse direction (in raw sensor units)

        :type: float
        """
    @reverseSoftLimitThreshold.setter
    def reverseSoftLimitThreshold(self, arg0: float) -> None:
        """
        Threshold for soft limits in reverse direction (in raw sensor units)
        """
    @property
    def slot0(self) -> SlotConfiguration:
        """
        Configuration for slot 0

        :type: SlotConfiguration
        """
    @slot0.setter
    def slot0(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 0
        """
    @property
    def slot1(self) -> SlotConfiguration:
        """
        Configuration for slot 1

        :type: SlotConfiguration
        """
    @slot1.setter
    def slot1(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 1
        """
    @property
    def slot2(self) -> SlotConfiguration:
        """
        Configuration for slot 2

        :type: SlotConfiguration
        """
    @slot2.setter
    def slot2(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 2
        """
    @property
    def slot3(self) -> SlotConfiguration:
        """
        Configuration for slot 3

        :type: SlotConfiguration
        """
    @slot3.setter
    def slot3(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 3
        """
    @property
    def softLimitDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote soft limit is lost on CAN bus

        :type: bool
        """
    @softLimitDisableNeutralOnLOS.setter
    def softLimitDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote soft limit is lost on CAN bus
        """
    @property
    def trajectoryInterpolationEnable(self) -> bool:
        """
        Enable motion profile trajectory point interpolation (defaults to true).

        :type: bool
        """
    @trajectoryInterpolationEnable.setter
    def trajectoryInterpolationEnable(self, arg0: bool) -> None:
        """
        Enable motion profile trajectory point interpolation (defaults to true).
        """
    @property
    def velocityMeasurementPeriod(self) -> sensors.SensorVelocityMeasPeriod:
        """
        Desired period for velocity measurement

        :type: sensors.SensorVelocityMeasPeriod
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: sensors.SensorVelocityMeasPeriod) -> None:
        """
        Desired period for velocity measurement
        """
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Desired window for velocity measurement

        :type: int
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        """
        Desired window for velocity measurement
        """
    @property
    def voltageCompSaturation(self) -> float:
        """
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.

        :type: float
        """
    @voltageCompSaturation.setter
    def voltageCompSaturation(self, arg0: float) -> None:
        """
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        """
    @property
    def voltageMeasurementFilter(self) -> int:
        """
        Number of samples in rolling average for voltage

        :type: int
        """
    @voltageMeasurementFilter.setter
    def voltageMeasurementFilter(self, arg0: int) -> None:
        """
        Number of samples in rolling average for voltage
        """
    pass
class BaseTalonPIDSetConfigUtil():
    """
    Util class to help with BaseTalon's PID configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: BaseTalonPIDSetConfiguration) -> bool: ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: BaseTalonPIDSetConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class BaseTalonPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to BaseTalon's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @property
    def selectedFeedbackSensor(self) -> FeedbackDevice:
        """
        Feedback device for a particular PID loop.
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode

        :type: FeedbackDevice
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: FeedbackDevice) -> None:
        """
        Feedback device for a particular PID loop.
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode
        """
    pass
class BufferedTrajectoryPointStream():
    """
    Stream of trajectory points for Talon/Victor motion profiling.
    """
    def __init__(self) -> None: ...
    def clear(self) -> ErrorCode: 
        """
        Clear all trajectory points.

        :returns: nonzero error code if operation fails.
        """
    def getHandle(self) -> capsule: 
        """
        :returns: raw handle for resource management.
        """
    @typing.overload
    def write(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Write a single trajectory point into the buffer.

        :returns: nonzero error code if operation fails.

        Writes an array of trajectory point into the buffer.

        :returns: nonzero error code if operation fails.
        """
    @typing.overload
    def write(self, trajPts: TrajectoryPoint, trajPtCount: int) -> ErrorCode: ...
    pass
class CANBusAddressable():
    """
    Simple address holder.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a CANBusAddressable device

        :param deviceNumber: CAN Device ID of device
        """
    def getDeviceNumber(self) -> int: 
        """
        :returns: CAN device number of device
        """
    pass
class CANifier(CANBusAddressable):
    """
    CTRE CANifier

    Device for interfacing common devices to the CAN bus.
    """
    class GeneralPin():
        """
        General IO Pins on the CANifier

        Members:

          QUAD_IDX : Quadrature Idx pin

          QUAD_B : Quadrature B pin

          QUAD_A : Quadrature A pin

          LIMR : Reverse limit pin

          LIMF : Forward limit pin

          SDA : SDA pin

          SCL : SCL pin

          SPI_CS : SPI_CS pin

          SPI_MISO_PWM2P : SPI_MISO_PWM2 pin

          SPI_MOSI_PWM1P : SPI_MOSI_PWM1 pin

          SPI_CLK_PWM0P : SPI_CLK_PWM0 pin
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        LIMF: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.LIMF: 4>
        LIMR: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.LIMR: 3>
        QUAD_A: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.QUAD_A: 2>
        QUAD_B: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.QUAD_B: 1>
        QUAD_IDX: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.QUAD_IDX: 0>
        SCL: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SCL: 6>
        SDA: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SDA: 5>
        SPI_CLK_PWM0P: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SPI_CLK_PWM0P: 10>
        SPI_CS: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SPI_CS: 7>
        SPI_MISO_PWM2P: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SPI_MISO_PWM2P: 8>
        SPI_MOSI_PWM1P: ctre._ctre.CANifier.GeneralPin # value = <GeneralPin.SPI_MOSI_PWM1P: 9>
        __members__: dict # value = {'QUAD_IDX': <GeneralPin.QUAD_IDX: 0>, 'QUAD_B': <GeneralPin.QUAD_B: 1>, 'QUAD_A': <GeneralPin.QUAD_A: 2>, 'LIMR': <GeneralPin.LIMR: 3>, 'LIMF': <GeneralPin.LIMF: 4>, 'SDA': <GeneralPin.SDA: 5>, 'SCL': <GeneralPin.SCL: 6>, 'SPI_CS': <GeneralPin.SPI_CS: 7>, 'SPI_MISO_PWM2P': <GeneralPin.SPI_MISO_PWM2P: 8>, 'SPI_MOSI_PWM1P': <GeneralPin.SPI_MOSI_PWM1P: 9>, 'SPI_CLK_PWM0P': <GeneralPin.SPI_CLK_PWM0P: 10>}
        pass
    class LEDChannel():
        """
        Enum for the LED Output Channels

        Members:

          A : LED Channel A

          B : LED Channel B

          C : LED Channel C
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        A: ctre._ctre.CANifier.LEDChannel # value = <LEDChannel.A: 0>
        B: ctre._ctre.CANifier.LEDChannel # value = <LEDChannel.B: 1>
        C: ctre._ctre.CANifier.LEDChannel # value = <LEDChannel.C: 2>
        __members__: dict # value = {'A': <LEDChannel.A: 0>, 'B': <LEDChannel.B: 1>, 'C': <LEDChannel.C: 2>}
        pass
    class PWMChannel():
        """
        Enum for the PWM Input Channels

        Members:

          PWMChannel0 : PWM Channel 0

          PWMChannel1 : PWM Channel 1

          PWMChannel2 : PWM Channel 2

          PWMChannel3 : PWM Channel 3
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        PWMChannel0: ctre._ctre.CANifier.PWMChannel # value = <PWMChannel.PWMChannel0: 0>
        PWMChannel1: ctre._ctre.CANifier.PWMChannel # value = <PWMChannel.PWMChannel1: 1>
        PWMChannel2: ctre._ctre.CANifier.PWMChannel # value = <PWMChannel.PWMChannel2: 2>
        PWMChannel3: ctre._ctre.CANifier.PWMChannel # value = <PWMChannel.PWMChannel3: 3>
        __members__: dict # value = {'PWMChannel0': <PWMChannel.PWMChannel0: 0>, 'PWMChannel1': <PWMChannel.PWMChannel1: 1>, 'PWMChannel2': <PWMChannel.PWMChannel2: 2>, 'PWMChannel3': <PWMChannel.PWMChannel3: 3>}
        pass
    class PinValues():
        """
        Structure to hold the pin values.
        """
        def __init__(self) -> None: ...
        @property
        def LIMF(self) -> bool:
            """
            Forward limit pin

            :type: bool
            """
        @LIMF.setter
        def LIMF(self, arg0: bool) -> None:
            """
            Forward limit pin
            """
        @property
        def LIMR(self) -> bool:
            """
            Reverse limit pin

            :type: bool
            """
        @LIMR.setter
        def LIMR(self, arg0: bool) -> None:
            """
            Reverse limit pin
            """
        @property
        def QUAD_A(self) -> bool:
            """
            Quadrature A pin

            :type: bool
            """
        @QUAD_A.setter
        def QUAD_A(self, arg0: bool) -> None:
            """
            Quadrature A pin
            """
        @property
        def QUAD_B(self) -> bool:
            """
            Quadrature B pin

            :type: bool
            """
        @QUAD_B.setter
        def QUAD_B(self, arg0: bool) -> None:
            """
            Quadrature B pin
            """
        @property
        def QUAD_IDX(self) -> bool:
            """
            Quadrature Idx pin

            :type: bool
            """
        @QUAD_IDX.setter
        def QUAD_IDX(self, arg0: bool) -> None:
            """
            Quadrature Idx pin
            """
        @property
        def SCL(self) -> bool:
            """
            SCL pin

            :type: bool
            """
        @SCL.setter
        def SCL(self, arg0: bool) -> None:
            """
            SCL pin
            """
        @property
        def SDA(self) -> bool:
            """
            SDA pin

            :type: bool
            """
        @SDA.setter
        def SDA(self, arg0: bool) -> None:
            """
            SDA pin
            """
        @property
        def SPI_CLK_PWM0(self) -> bool:
            """
            SPI_CLK_PWM0 pin

            :type: bool
            """
        @SPI_CLK_PWM0.setter
        def SPI_CLK_PWM0(self, arg0: bool) -> None:
            """
            SPI_CLK_PWM0 pin
            """
        @property
        def SPI_CS_PWM3(self) -> bool:
            """
            SPI_CS_PWM3 pin

            :type: bool
            """
        @SPI_CS_PWM3.setter
        def SPI_CS_PWM3(self, arg0: bool) -> None:
            """
            SPI_CS_PWM3 pin
            """
        @property
        def SPI_MISO_PWM2(self) -> bool:
            """
            SPI_MISO_PWM2 pin

            :type: bool
            """
        @SPI_MISO_PWM2.setter
        def SPI_MISO_PWM2(self, arg0: bool) -> None:
            """
            SPI_MISO_PWM2 pin
            """
        @property
        def SPI_MOSI_PWM1(self) -> bool:
            """
            SPI_MOSI_PWM1 pin

            :type: bool
            """
        @SPI_MOSI_PWM1.setter
        def SPI_MOSI_PWM1(self, arg0: bool) -> None:
            """
            SPI_MOSI_PWM1 pin
            """
        pass
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor.

        :param deviceNumber: The CAN Device ID of the CANifier.
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears the Sticky Faults

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings to defaults (overloaded so timeoutMs is 50 ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param:     Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param:         Parameter enumeration
        :param valueToSend:   Value to send to parameter
        :param valueReceived: Reference to integer to receive
        :param subValue:      SubValue of parameter
        :param ordinal:       Ordinal of parameter
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, ordinal: int, timeoutMs: int) -> typing.Tuple[ErrorCode, int, int]: ...
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.

        :param period:    Desired period for the velocity measurement.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another
                           value is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllCANifiers() -> None: 
        """
        Destructs all CANifier objects
        """
    def enablePWMOutput(self, pwmChannel: int, bEnable: bool) -> ErrorCode: 
        """
        Enables PWM Outputs
        Currently supports PWM 0, PWM 1, and PWM 2

        :param pwmChannel: Index of the PWM channel to enable.
        :param bEnable:    True" enables output on the pwm channel.
        """
    def getAllConfigs(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getFaults(self, toFill: CANifierFaults) -> ErrorCode: 
        """
        Gets the CANifier fault status

        :param toFill: Container for fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device.
        """
    def getGeneralInput(self, inputPin: CANifier.GeneralPin) -> bool: 
        """
        Gets the state of the specified pin

        :param inputPin: The index of the pin.

        :returns: The state of the pin.
        """
    def getGeneralInputs(self, allPins: CANifier.PinValues) -> ErrorCode: 
        """
        Gets the state of all General Pins

        :param allPins: A structure to fill with the current state of all pins.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.

        This function can be used to retrieve those error codes.

        :returns: The last ErrorCode generated.
        """
    def getPWMInput(self, pwmChannel: CANifier.PWMChannel) -> typing.Tuple[ErrorCode, typing.List[float[2]]]: 
        """
        Gets the PWM Input

        :param pwmChannel:          PWM channel to get.
        :param pulseWidthAndPeriod: Double array to hold Duty Cycle [0] and Period [1].
        """
    def getQuadraturePosition(self) -> int: 
        """
        Gets the quadrature encoder's position

        :returns: Position of encoder
        """
    def getQuadratureVelocity(self) -> int: 
        """
        Gets the quadrature encoder's velocity

        :returns: Velocity of encoder
        """
    def getStatusFramePeriod(self, frame: CANifierStatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: CANifierStickyFaults) -> ErrorCode: 
        """
        Gets the CANifier sticky fault status

        :param toFill: Container for sticky fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def setControlFramePeriod(self, frame: CANifierControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setGeneralOutput(self, outputPin: CANifier.GeneralPin, outputValue: bool, outputEnable: bool) -> ErrorCode: 
        """
        Sets the output of a General Pin

        :param outputPin:    The pin to use as output.
        :param outputValue:  The desired output state.
        :param outputEnable: Whether this pin is an output. "True" enables output.
        """
    def setGeneralOutputs(self, outputBits: int, isOutputBits: int) -> ErrorCode: 
        """
        Sets the output of all General Pins

        :param outputBits:   A bit mask of all the output states.  LSB->MSB is in the order of the #GeneralPin enum.
        :param isOutputBits: A boolean bit mask that sets the pins to be outputs or inputs.  A bit of 1 enables output.
        """
    def setLEDOutput(self, percentOutput: float, ledChannel: CANifier.LEDChannel) -> ErrorCode: 
        """
        Sets the LED Output

        :param percentOutput: Output duty cycle expressed as percentage.
        :param ledChannel:    Channel to set the output of.
        """
    def setPWMOutput(self, pwmChannel: int, dutyCycle: float) -> ErrorCode: 
        """
        Sets the PWM Output
        Currently supports PWM 0, PWM 1, and PWM 2

        :param pwmChannel: Index of the PWM channel to output.
        :param dutyCycle:  Duty Cycle (0 to 1) to output.  Default period of the signal is 4.2 ms.
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the quadrature encoder's position

        :param newPosition: Position to set
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: CANifierStatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        :param statusFrame: Frame whose period is to be changed.
        :param periodMs:    Period in ms for the given frame.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @property
    def PWMChannelCount(self) -> int:
        """
        Number of PWM channels available to CANifier

        :type: int
        """
    pass
class CANifierConfigUtils():
    """
    Util class to help with configuring CANifier
    """
    def __init__(self) -> None: ...
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def customParam0Different(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def customParam1Different(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: CANifierConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: CANifierConfiguration) -> bool: ...
    pass
class CANifierConfiguration(CustomParamConfiguration):
    """
    Configurables available to CANifier
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Whether to clear sensor position on forward limit

        :type: bool
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on forward limit
        """
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Whether to clear sensor position on reverse limit

        :type: bool
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on reverse limit
        """
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Whether to clear sensor position on index

        :type: bool
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on index
        """
    @property
    def velocityMeasurementPeriod(self) -> sensors.SensorVelocityMeasPeriod:
        """
        Velocity measurement period to use

        :type: sensors.SensorVelocityMeasPeriod
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: sensors.SensorVelocityMeasPeriod) -> None:
        """
        Velocity measurement period to use
        """
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Velocity measurement window to use

        :type: int
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        """
        Velocity measurement window to use
        """
    pass
class CANifierControlFrame():
    """
    Enumerated type for status frame types.

    Members:

      CANifier_Control_1_General

      CANifier_Control_2_PwmOutput
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    CANifier_Control_1_General: ctre._ctre.CANifierControlFrame # value = <CANifierControlFrame.CANifier_Control_1_General: 50593792>
    CANifier_Control_2_PwmOutput: ctre._ctre.CANifierControlFrame # value = <CANifierControlFrame.CANifier_Control_2_PwmOutput: 50593856>
    __members__: dict # value = {'CANifier_Control_1_General': <CANifierControlFrame.CANifier_Control_1_General: 50593792>, 'CANifier_Control_2_PwmOutput': <CANifierControlFrame.CANifier_Control_2_PwmOutput: 50593856>}
    pass
class CANifierFaults():
    """
    Faults available to CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class CANifierStatusFrame():
    """
    Enumerated type for status frame types.

    Members:

      Status_1_General

      Status_2_General

      Status_3_PwmInputs0

      Status_4_PwmInputs1

      Status_5_PwmInputs2

      Status_6_PwmInputs3

      Status_8_Misc
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Status_1_General: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_1_General: 267264>
    Status_2_General: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_2_General: 267328>
    Status_3_PwmInputs0: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_3_PwmInputs0: 267392>
    Status_4_PwmInputs1: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_4_PwmInputs1: 267456>
    Status_5_PwmInputs2: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_5_PwmInputs2: 267520>
    Status_6_PwmInputs3: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_6_PwmInputs3: 267584>
    Status_8_Misc: ctre._ctre.CANifierStatusFrame # value = <CANifierStatusFrame.Status_8_Misc: 267712>
    __members__: dict # value = {'Status_1_General': <CANifierStatusFrame.Status_1_General: 267264>, 'Status_2_General': <CANifierStatusFrame.Status_2_General: 267328>, 'Status_3_PwmInputs0': <CANifierStatusFrame.Status_3_PwmInputs0: 267392>, 'Status_4_PwmInputs1': <CANifierStatusFrame.Status_4_PwmInputs1: 267456>, 'Status_5_PwmInputs2': <CANifierStatusFrame.Status_5_PwmInputs2: 267520>, 'Status_6_PwmInputs3': <CANifierStatusFrame.Status_6_PwmInputs3: 267584>, 'Status_8_Misc': <CANifierStatusFrame.Status_8_Misc: 267712>}
    pass
class CANifierStickyFaults():
    """
    Sticky Faults for CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class CANifierVelocityMeasPeriod():
    """
    Enum for velocity periods used for CANifier

    Members:

      Period_1Ms : 1ms velocity measurement period

      Period_2Ms : 2ms velocity measurement period

      Period_5Ms : 5ms velocity measurement period

      Period_10Ms : 10ms velocity measurement period

      Period_20Ms : 20ms velocity measurement period

      Period_25Ms : 25ms velocity measurement period

      Period_50Ms : 50ms velocity measurement period

      Period_100Ms : 100ms velocity measurement period
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Period_100Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_100Ms: 100>
    Period_10Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_10Ms: 10>
    Period_1Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_1Ms: 1>
    Period_20Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_20Ms: 20>
    Period_25Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_25Ms: 25>
    Period_2Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_2Ms: 2>
    Period_50Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_50Ms: 50>
    Period_5Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = <CANifierVelocityMeasPeriod.Period_5Ms: 5>
    __members__: dict # value = {'Period_1Ms': <CANifierVelocityMeasPeriod.Period_1Ms: 1>, 'Period_2Ms': <CANifierVelocityMeasPeriod.Period_2Ms: 2>, 'Period_5Ms': <CANifierVelocityMeasPeriod.Period_5Ms: 5>, 'Period_10Ms': <CANifierVelocityMeasPeriod.Period_10Ms: 10>, 'Period_20Ms': <CANifierVelocityMeasPeriod.Period_20Ms: 20>, 'Period_25Ms': <CANifierVelocityMeasPeriod.Period_25Ms: 25>, 'Period_50Ms': <CANifierVelocityMeasPeriod.Period_50Ms: 50>, 'Period_100Ms': <CANifierVelocityMeasPeriod.Period_100Ms: 100>}
    pass
class ControlFrame():
    """
    Control Frames for motor controllers

    Members:

      Control_3_General : Control

      Control_4_Advanced : Advanced Control

      Control_6_MotProfAddTrajPoint : Trajectory points
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Control_3_General: ctre._ctre.ControlFrame # value = <ControlFrame.Control_3_General: 262272>
    Control_4_Advanced: ctre._ctre.ControlFrame # value = <ControlFrame.Control_4_Advanced: 262336>
    Control_6_MotProfAddTrajPoint: ctre._ctre.ControlFrame # value = <ControlFrame.Control_6_MotProfAddTrajPoint: 262464>
    __members__: dict # value = {'Control_3_General': <ControlFrame.Control_3_General: 262272>, 'Control_4_Advanced': <ControlFrame.Control_4_Advanced: 262336>, 'Control_6_MotProfAddTrajPoint': <ControlFrame.Control_6_MotProfAddTrajPoint: 262464>}
    pass
class ControlFrameEnhanced():
    """
    Control Frames for enhanced motor controllers

    Members:

      Control_3_General_ : Control

      Control_4_Advanced_ : Advanced Control

      Control_5_FeedbackOutputOverride_ : Override feedback output

      Control_6_MotProfAddTrajPoint_ : Trajectory points
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Control_3_General_: ctre._ctre.ControlFrameEnhanced # value = <ControlFrameEnhanced.Control_3_General_: 262272>
    Control_4_Advanced_: ctre._ctre.ControlFrameEnhanced # value = <ControlFrameEnhanced.Control_4_Advanced_: 262336>
    Control_5_FeedbackOutputOverride_: ctre._ctre.ControlFrameEnhanced # value = <ControlFrameEnhanced.Control_5_FeedbackOutputOverride_: 262400>
    Control_6_MotProfAddTrajPoint_: ctre._ctre.ControlFrameEnhanced # value = <ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_: 262464>
    __members__: dict # value = {'Control_3_General_': <ControlFrameEnhanced.Control_3_General_: 262272>, 'Control_4_Advanced_': <ControlFrameEnhanced.Control_4_Advanced_: 262336>, 'Control_5_FeedbackOutputOverride_': <ControlFrameEnhanced.Control_5_FeedbackOutputOverride_: 262400>, 'Control_6_MotProfAddTrajPoint_': <ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_: 262464>}
    pass
class ControlMode():
    """
    Choose the control mode for a motor controller.
    Consult product specific documentation to determine what is available/supported.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.

      Disabled : Disable Motor Controller
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Current: ctre._ctre.ControlMode # value = <ControlMode.Current: 3>
    Disabled: ctre._ctre.ControlMode # value = <ControlMode.Disabled: 15>
    Follower: ctre._ctre.ControlMode # value = <ControlMode.Follower: 5>
    MotionMagic: ctre._ctre.ControlMode # value = <ControlMode.MotionMagic: 7>
    MotionProfile: ctre._ctre.ControlMode # value = <ControlMode.MotionProfile: 6>
    MotionProfileArc: ctre._ctre.ControlMode # value = <ControlMode.MotionProfileArc: 10>
    MusicTone: ctre._ctre.ControlMode # value = <ControlMode.MusicTone: 13>
    PercentOutput: ctre._ctre.ControlMode # value = <ControlMode.PercentOutput: 0>
    Position: ctre._ctre.ControlMode # value = <ControlMode.Position: 1>
    Velocity: ctre._ctre.ControlMode # value = <ControlMode.Velocity: 2>
    __members__: dict # value = {'PercentOutput': <ControlMode.PercentOutput: 0>, 'Position': <ControlMode.Position: 1>, 'Velocity': <ControlMode.Velocity: 2>, 'Current': <ControlMode.Current: 3>, 'Follower': <ControlMode.Follower: 5>, 'MotionProfile': <ControlMode.MotionProfile: 6>, 'MotionMagic': <ControlMode.MotionMagic: 7>, 'MotionProfileArc': <ControlMode.MotionProfileArc: 10>, 'MusicTone': <ControlMode.MusicTone: 13>, 'Disabled': <ControlMode.Disabled: 15>}
    pass
class BaseMotorControllerUtil(CustomParamConfigUtil):
    """
    Util class to help with Base Motor Controller configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def auxPIDPolarityDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def closedloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def feedbackNotContinuousDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def forwardSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def forwardSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def limitSwitchDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionAccelerationDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionCruiseVelocityDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionProfileTrajectoryPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionSCurveStrength(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def neutralDeadbandDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def nominalOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def nominalOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def openloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def peakOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def peakOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def pulseWidthPeriod_EdgesPerRotDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def pulseWidthPeriod_FilterWindowSzDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def remoteSensorClosedLoopDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def reverseSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def reverseSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def softLimitDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def trajectoryInterpolationEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def voltageCompSaturationDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def voltageMeasurementFilterDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    pass
class BaseTalonConfiguration(BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to BaseTalon
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @property
    def auxiliaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Auxiliary PID configuration

        :type: BaseTalonPIDSetConfiguration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        """
        Auxiliary PID configuration
        """
    @property
    def diff0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.diff0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.diff0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode

        :type: FeedbackDevice
        """
    @diff0Term.setter
    def diff0Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Diff 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.diff0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.diff0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode
        """
    @property
    def diff1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.diff1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.diff1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode

        :type: FeedbackDevice
        """
    @diff1Term.setter
    def diff1Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Diff 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.diff1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.diff1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode
        """
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Forward limit switch normally open/closed
        """
    @property
    def forwardLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: LimitSwitchSource
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def primaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Primary PID configuration

        :type: BaseTalonPIDSetConfiguration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        """
        Primary PID configuration
        """
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Reverse limit switch normally open/closed
        """
    @property
    def reverseLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: LimitSwitchSource
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def sum0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.sum0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.sum0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode

        :type: FeedbackDevice
        """
    @sum0Term.setter
    def sum0Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Sum 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.sum0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.sum0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode
        """
    @property
    def sum1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.sum1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.sum1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode

        :type: FeedbackDevice
        """
    @sum1Term.setter
    def sum1Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Sum 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *       @code
        *       configs.sum1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *       configs.sum1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *       @endcode
        """
    pass
class DemandType():
    """
    How to interpret a demand value.

    Members:

      Neutral : Ignore the demand value and apply neutral/no-change.

      AuxPID : When closed-looping, set the target of the aux PID loop to the demand value.

    When following, follow the processed output of the combined
    primary/aux PID output of the master.  The demand value is ignored.
    Although it is much cleaner to use the 2-param Follow() in such cases.

      ArbitraryFeedForward : When closed-looping, add demand arbitrarily to the closed-loop output.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    ArbitraryFeedForward: ctre._ctre.DemandType # value = <DemandType.ArbitraryFeedForward: 2>
    AuxPID: ctre._ctre.DemandType # value = <DemandType.AuxPID: 1>
    Neutral: ctre._ctre.DemandType # value = <DemandType.Neutral: 0>
    __members__: dict # value = {'Neutral': <DemandType.Neutral: 0>, 'AuxPID': <DemandType.AuxPID: 1>, 'ArbitraryFeedForward': <DemandType.ArbitraryFeedForward: 2>}
    pass
class ErrorCode():
    """
    Members:

      OK

      OKAY : No Error - Function executed as expected

      CAN_MSG_STALE

      CAN_TX_FULL

      TxFailed : Could not transmit the CAN frame.

      InvalidParamValue : Caller passed an invalid param

      CAN_INVALID_PARAM

      RxTimeout : CAN frame has not been received within specified period of time.

      CAN_MSG_NOT_FOUND

      TxTimeout : Not used.

      CAN_NO_MORE_TX_JOBS

      UnexpectedArbId : Specified CAN Id is invalid.

      CAN_NO_SESSIONS_AVAIL

      BufferFull : Caller attempted to insert data into a buffer that is full.

      CAN_OVERFLOW

      SensorNotPresent : Sensor is not present

      FirmwareTooOld

      CouldNotChangePeriod

      BufferFailure

      FirwmwareNonFRC

      GeneralError : User Specified General Error

      GENERAL_ERROR

      SIG_NOT_UPDATED

      SigNotUpdated : Have not received an value response for signal.

      NotAllPIDValuesUpdated

      GEN_PORT_ERROR

      PORT_MODULE_TYPE_MISMATCH

      GEN_MODULE_ERROR

      MODULE_NOT_INIT_SET_ERROR

      MODULE_NOT_INIT_GET_ERROR

      WheelRadiusTooSmall

      TicksPerRevZero

      DistanceBetweenWheelsTooSmall

      GainsAreNotSet

      WrongRemoteLimitSwitchSource

      DoubleVoltageCompensatingWPI

      CANdleAnimSlotOutOfBounds

      IncompatibleMode

      InvalidHandle : Handle does not match stored map of handles

      FeatureRequiresHigherFirm

      MotorControllerFeatureRequiresHigherFirm

      TalonFeatureRequiresHigherFirm

      ConfigFactoryDefaultRequiresHigherFirm

      ConfigMotionSCurveRequiresHigherFirm

      TalonFXFirmwarePreVBatDetect

      CANdleAnimationsRequireHigherFirm

      LibraryCouldNotBeLoaded

      MissingRoutineInLibrary

      ResourceNotAvailable

      MusicFileNotFound

      MusicFileWrongSize

      MusicFileTooNew

      MusicFileInvalid

      InvalidOrchestraAction

      MusicFileTooOld

      MusicInterrupted

      MusicNotSupported

      kInvalidInterface

      kInvalidGuid

      kInvalidClass

      kInvalidProtocol

      kInvalidPath

      kGeneralWinUsbError

      kFailedSetup

      kListenFailed

      kSendFailed

      kReceiveFailed

      kInvalidRespFormat

      kWinUsbInitFailed

      kWinUsbQueryFailed

      kWinUsbGeneralError

      kAccessDenied

      kFirmwareInvalidResponse

      PulseWidthSensorNotPresent : Special Code for "isSensorPresent"

      GeneralWarning

      FeatureNotSupported

      NotImplemented

      FirmVersionCouldNotBeRetrieved

      FeaturesNotAvailableYet

      ControlModeNotValid

      ControlModeNotSupportedYet

      CascadedPIDNotSupporteYet

      AuxiliaryPIDNotSupportedYet

      RemoteSensorsNotSupportedYet

      MotProfFirmThreshold

      MotProfFirmThreshold2

      SimDeviceNotFound

      SimPhysicsTypeNotSupported

      SimDeviceAlreadyExists
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    AuxiliaryPIDNotSupportedYet: ctre._ctre.ErrorCode # value = <ErrorCode.CascadedPIDNotSupporteYet: 107>
    BufferFailure: ctre._ctre.ErrorCode # value = <ErrorCode.BufferFailure: -10>
    BufferFull: ctre._ctre.ErrorCode # value = <ErrorCode.BufferFull: 6>
    CAN_INVALID_PARAM: ctre._ctre.ErrorCode # value = <ErrorCode.InvalidParamValue: -2>
    CAN_MSG_NOT_FOUND: ctre._ctre.ErrorCode # value = <ErrorCode.RxTimeout: -3>
    CAN_MSG_STALE: ctre._ctre.ErrorCode # value = <ErrorCode.CAN_MSG_STALE: 1>
    CAN_NO_MORE_TX_JOBS: ctre._ctre.ErrorCode # value = <ErrorCode.TxTimeout: -4>
    CAN_NO_SESSIONS_AVAIL: ctre._ctre.ErrorCode # value = <ErrorCode.UnexpectedArbId: -5>
    CAN_OVERFLOW: ctre._ctre.ErrorCode # value = <ErrorCode.CAN_OVERFLOW: -6>
    CAN_TX_FULL: ctre._ctre.ErrorCode # value = <ErrorCode.CAN_TX_FULL: -1>
    CANdleAnimSlotOutOfBounds: ctre._ctre.ErrorCode # value = <ErrorCode.CANdleAnimSlotOutOfBounds: -506>
    CANdleAnimationsRequireHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.CANdleAnimationsRequireHigherFirm: -705>
    CascadedPIDNotSupporteYet: ctre._ctre.ErrorCode # value = <ErrorCode.CascadedPIDNotSupporteYet: 107>
    ConfigFactoryDefaultRequiresHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.ConfigFactoryDefaultRequiresHigherFirm: -702>
    ConfigMotionSCurveRequiresHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.ConfigMotionSCurveRequiresHigherFirm: -703>
    ControlModeNotSupportedYet: ctre._ctre.ErrorCode # value = <ErrorCode.ControlModeNotSupportedYet: 106>
    ControlModeNotValid: ctre._ctre.ErrorCode # value = <ErrorCode.ControlModeNotValid: 105>
    CouldNotChangePeriod: ctre._ctre.ErrorCode # value = <ErrorCode.CouldNotChangePeriod: -9>
    DistanceBetweenWheelsTooSmall: ctre._ctre.ErrorCode # value = <ErrorCode.DistanceBetweenWheelsTooSmall: -502>
    DoubleVoltageCompensatingWPI: ctre._ctre.ErrorCode # value = <ErrorCode.DoubleVoltageCompensatingWPI: -505>
    FeatureNotSupported: ctre._ctre.ErrorCode # value = <ErrorCode.FeatureNotSupported: 101>
    FeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.FeatureRequiresHigherFirm: -700>
    FeaturesNotAvailableYet: ctre._ctre.ErrorCode # value = <ErrorCode.FeaturesNotAvailableYet: 104>
    FirmVersionCouldNotBeRetrieved: ctre._ctre.ErrorCode # value = <ErrorCode.FirmVersionCouldNotBeRetrieved: 103>
    FirmwareTooOld: ctre._ctre.ErrorCode # value = <ErrorCode.FirmwareTooOld: -8>
    FirwmwareNonFRC: ctre._ctre.ErrorCode # value = <ErrorCode.FirwmwareNonFRC: -11>
    GENERAL_ERROR: ctre._ctre.ErrorCode # value = <ErrorCode.GeneralError: -100>
    GEN_MODULE_ERROR: ctre._ctre.ErrorCode # value = <ErrorCode.GEN_MODULE_ERROR: -400>
    GEN_PORT_ERROR: ctre._ctre.ErrorCode # value = <ErrorCode.GEN_PORT_ERROR: -300>
    GainsAreNotSet: ctre._ctre.ErrorCode # value = <ErrorCode.GainsAreNotSet: -503>
    GeneralError: ctre._ctre.ErrorCode # value = <ErrorCode.GeneralError: -100>
    GeneralWarning: ctre._ctre.ErrorCode # value = <ErrorCode.GeneralWarning: 100>
    IncompatibleMode: ctre._ctre.ErrorCode # value = <ErrorCode.IncompatibleMode: -600>
    InvalidHandle: ctre._ctre.ErrorCode # value = <ErrorCode.InvalidHandle: -601>
    InvalidOrchestraAction: ctre._ctre.ErrorCode # value = <ErrorCode.InvalidOrchestraAction: -904>
    InvalidParamValue: ctre._ctre.ErrorCode # value = <ErrorCode.InvalidParamValue: -2>
    LibraryCouldNotBeLoaded: ctre._ctre.ErrorCode # value = <ErrorCode.LibraryCouldNotBeLoaded: -800>
    MODULE_NOT_INIT_GET_ERROR: ctre._ctre.ErrorCode # value = <ErrorCode.MODULE_NOT_INIT_GET_ERROR: -402>
    MODULE_NOT_INIT_SET_ERROR: ctre._ctre.ErrorCode # value = <ErrorCode.MODULE_NOT_INIT_SET_ERROR: -401>
    MissingRoutineInLibrary: ctre._ctre.ErrorCode # value = <ErrorCode.MissingRoutineInLibrary: -801>
    MotProfFirmThreshold: ctre._ctre.ErrorCode # value = <ErrorCode.MotProfFirmThreshold: 109>
    MotProfFirmThreshold2: ctre._ctre.ErrorCode # value = <ErrorCode.MotProfFirmThreshold2: 110>
    MotorControllerFeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>
    MusicFileInvalid: ctre._ctre.ErrorCode # value = <ErrorCode.MusicFileInvalid: -903>
    MusicFileNotFound: ctre._ctre.ErrorCode # value = <ErrorCode.MusicFileNotFound: -900>
    MusicFileTooNew: ctre._ctre.ErrorCode # value = <ErrorCode.MusicFileTooNew: -902>
    MusicFileTooOld: ctre._ctre.ErrorCode # value = <ErrorCode.MusicFileTooOld: -905>
    MusicFileWrongSize: ctre._ctre.ErrorCode # value = <ErrorCode.MusicFileWrongSize: -901>
    MusicInterrupted: ctre._ctre.ErrorCode # value = <ErrorCode.MusicInterrupted: -906>
    MusicNotSupported: ctre._ctre.ErrorCode # value = <ErrorCode.MusicNotSupported: -907>
    NotAllPIDValuesUpdated: ctre._ctre.ErrorCode # value = <ErrorCode.NotAllPIDValuesUpdated: -201>
    NotImplemented: ctre._ctre.ErrorCode # value = <ErrorCode.NotImplemented: 102>
    OK: ctre._ctre.ErrorCode # value = <ErrorCode.OK: 0>
    OKAY: ctre._ctre.ErrorCode # value = <ErrorCode.OK: 0>
    PORT_MODULE_TYPE_MISMATCH: ctre._ctre.ErrorCode # value = <ErrorCode.PORT_MODULE_TYPE_MISMATCH: -301>
    PulseWidthSensorNotPresent: ctre._ctre.ErrorCode # value = <ErrorCode.PulseWidthSensorNotPresent: 10>
    RemoteSensorsNotSupportedYet: ctre._ctre.ErrorCode # value = <ErrorCode.RemoteSensorsNotSupportedYet: 108>
    ResourceNotAvailable: ctre._ctre.ErrorCode # value = <ErrorCode.ResourceNotAvailable: -802>
    RxTimeout: ctre._ctre.ErrorCode # value = <ErrorCode.RxTimeout: -3>
    SIG_NOT_UPDATED: ctre._ctre.ErrorCode # value = <ErrorCode.SIG_NOT_UPDATED: -200>
    SensorNotPresent: ctre._ctre.ErrorCode # value = <ErrorCode.SensorNotPresent: -7>
    SigNotUpdated: ctre._ctre.ErrorCode # value = <ErrorCode.SIG_NOT_UPDATED: -200>
    SimDeviceAlreadyExists: ctre._ctre.ErrorCode # value = <ErrorCode.SimDeviceAlreadyExists: 202>
    SimDeviceNotFound: ctre._ctre.ErrorCode # value = <ErrorCode.SimDeviceNotFound: 200>
    SimPhysicsTypeNotSupported: ctre._ctre.ErrorCode # value = <ErrorCode.SimPhysicsTypeNotSupported: 201>
    TalonFXFirmwarePreVBatDetect: ctre._ctre.ErrorCode # value = <ErrorCode.TalonFXFirmwarePreVBatDetect: -704>
    TalonFeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>
    TicksPerRevZero: ctre._ctre.ErrorCode # value = <ErrorCode.TicksPerRevZero: -501>
    TxFailed: ctre._ctre.ErrorCode # value = <ErrorCode.CAN_TX_FULL: -1>
    TxTimeout: ctre._ctre.ErrorCode # value = <ErrorCode.TxTimeout: -4>
    UnexpectedArbId: ctre._ctre.ErrorCode # value = <ErrorCode.UnexpectedArbId: -5>
    WheelRadiusTooSmall: ctre._ctre.ErrorCode # value = <ErrorCode.WheelRadiusTooSmall: -500>
    WrongRemoteLimitSwitchSource: ctre._ctre.ErrorCode # value = <ErrorCode.WrongRemoteLimitSwitchSource: -504>
    __members__: dict # value = {'OK': <ErrorCode.OK: 0>, 'OKAY': <ErrorCode.OK: 0>, 'CAN_MSG_STALE': <ErrorCode.CAN_MSG_STALE: 1>, 'CAN_TX_FULL': <ErrorCode.CAN_TX_FULL: -1>, 'TxFailed': <ErrorCode.CAN_TX_FULL: -1>, 'InvalidParamValue': <ErrorCode.InvalidParamValue: -2>, 'CAN_INVALID_PARAM': <ErrorCode.InvalidParamValue: -2>, 'RxTimeout': <ErrorCode.RxTimeout: -3>, 'CAN_MSG_NOT_FOUND': <ErrorCode.RxTimeout: -3>, 'TxTimeout': <ErrorCode.TxTimeout: -4>, 'CAN_NO_MORE_TX_JOBS': <ErrorCode.TxTimeout: -4>, 'UnexpectedArbId': <ErrorCode.UnexpectedArbId: -5>, 'CAN_NO_SESSIONS_AVAIL': <ErrorCode.UnexpectedArbId: -5>, 'BufferFull': <ErrorCode.BufferFull: 6>, 'CAN_OVERFLOW': <ErrorCode.CAN_OVERFLOW: -6>, 'SensorNotPresent': <ErrorCode.SensorNotPresent: -7>, 'FirmwareTooOld': <ErrorCode.FirmwareTooOld: -8>, 'CouldNotChangePeriod': <ErrorCode.CouldNotChangePeriod: -9>, 'BufferFailure': <ErrorCode.BufferFailure: -10>, 'FirwmwareNonFRC': <ErrorCode.FirwmwareNonFRC: -11>, 'GeneralError': <ErrorCode.GeneralError: -100>, 'GENERAL_ERROR': <ErrorCode.GeneralError: -100>, 'SIG_NOT_UPDATED': <ErrorCode.SIG_NOT_UPDATED: -200>, 'SigNotUpdated': <ErrorCode.SIG_NOT_UPDATED: -200>, 'NotAllPIDValuesUpdated': <ErrorCode.NotAllPIDValuesUpdated: -201>, 'GEN_PORT_ERROR': <ErrorCode.GEN_PORT_ERROR: -300>, 'PORT_MODULE_TYPE_MISMATCH': <ErrorCode.PORT_MODULE_TYPE_MISMATCH: -301>, 'GEN_MODULE_ERROR': <ErrorCode.GEN_MODULE_ERROR: -400>, 'MODULE_NOT_INIT_SET_ERROR': <ErrorCode.MODULE_NOT_INIT_SET_ERROR: -401>, 'MODULE_NOT_INIT_GET_ERROR': <ErrorCode.MODULE_NOT_INIT_GET_ERROR: -402>, 'WheelRadiusTooSmall': <ErrorCode.WheelRadiusTooSmall: -500>, 'TicksPerRevZero': <ErrorCode.TicksPerRevZero: -501>, 'DistanceBetweenWheelsTooSmall': <ErrorCode.DistanceBetweenWheelsTooSmall: -502>, 'GainsAreNotSet': <ErrorCode.GainsAreNotSet: -503>, 'WrongRemoteLimitSwitchSource': <ErrorCode.WrongRemoteLimitSwitchSource: -504>, 'DoubleVoltageCompensatingWPI': <ErrorCode.DoubleVoltageCompensatingWPI: -505>, 'CANdleAnimSlotOutOfBounds': <ErrorCode.CANdleAnimSlotOutOfBounds: -506>, 'IncompatibleMode': <ErrorCode.IncompatibleMode: -600>, 'InvalidHandle': <ErrorCode.InvalidHandle: -601>, 'FeatureRequiresHigherFirm': <ErrorCode.FeatureRequiresHigherFirm: -700>, 'MotorControllerFeatureRequiresHigherFirm': <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>, 'TalonFeatureRequiresHigherFirm': <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>, 'ConfigFactoryDefaultRequiresHigherFirm': <ErrorCode.ConfigFactoryDefaultRequiresHigherFirm: -702>, 'ConfigMotionSCurveRequiresHigherFirm': <ErrorCode.ConfigMotionSCurveRequiresHigherFirm: -703>, 'TalonFXFirmwarePreVBatDetect': <ErrorCode.TalonFXFirmwarePreVBatDetect: -704>, 'CANdleAnimationsRequireHigherFirm': <ErrorCode.CANdleAnimationsRequireHigherFirm: -705>, 'LibraryCouldNotBeLoaded': <ErrorCode.LibraryCouldNotBeLoaded: -800>, 'MissingRoutineInLibrary': <ErrorCode.MissingRoutineInLibrary: -801>, 'ResourceNotAvailable': <ErrorCode.ResourceNotAvailable: -802>, 'MusicFileNotFound': <ErrorCode.MusicFileNotFound: -900>, 'MusicFileWrongSize': <ErrorCode.MusicFileWrongSize: -901>, 'MusicFileTooNew': <ErrorCode.MusicFileTooNew: -902>, 'MusicFileInvalid': <ErrorCode.MusicFileInvalid: -903>, 'InvalidOrchestraAction': <ErrorCode.InvalidOrchestraAction: -904>, 'MusicFileTooOld': <ErrorCode.MusicFileTooOld: -905>, 'MusicInterrupted': <ErrorCode.MusicInterrupted: -906>, 'MusicNotSupported': <ErrorCode.MusicNotSupported: -907>, 'kInvalidInterface': <ErrorCode.kInvalidInterface: -1000>, 'kInvalidGuid': <ErrorCode.kInvalidGuid: -1001>, 'kInvalidClass': <ErrorCode.kInvalidClass: -1002>, 'kInvalidProtocol': <ErrorCode.kInvalidProtocol: -1003>, 'kInvalidPath': <ErrorCode.kInvalidPath: -1004>, 'kGeneralWinUsbError': <ErrorCode.kGeneralWinUsbError: -1005>, 'kFailedSetup': <ErrorCode.kFailedSetup: -1006>, 'kListenFailed': <ErrorCode.kListenFailed: -1007>, 'kSendFailed': <ErrorCode.kSendFailed: -1008>, 'kReceiveFailed': <ErrorCode.kReceiveFailed: -1009>, 'kInvalidRespFormat': <ErrorCode.kInvalidRespFormat: -1010>, 'kWinUsbInitFailed': <ErrorCode.kWinUsbInitFailed: -1011>, 'kWinUsbQueryFailed': <ErrorCode.kWinUsbQueryFailed: -1012>, 'kWinUsbGeneralError': <ErrorCode.kWinUsbGeneralError: -1013>, 'kAccessDenied': <ErrorCode.kAccessDenied: -1014>, 'kFirmwareInvalidResponse': <ErrorCode.kFirmwareInvalidResponse: -1015>, 'PulseWidthSensorNotPresent': <ErrorCode.PulseWidthSensorNotPresent: 10>, 'GeneralWarning': <ErrorCode.GeneralWarning: 100>, 'FeatureNotSupported': <ErrorCode.FeatureNotSupported: 101>, 'NotImplemented': <ErrorCode.NotImplemented: 102>, 'FirmVersionCouldNotBeRetrieved': <ErrorCode.FirmVersionCouldNotBeRetrieved: 103>, 'FeaturesNotAvailableYet': <ErrorCode.FeaturesNotAvailableYet: 104>, 'ControlModeNotValid': <ErrorCode.ControlModeNotValid: 105>, 'ControlModeNotSupportedYet': <ErrorCode.ControlModeNotSupportedYet: 106>, 'CascadedPIDNotSupporteYet': <ErrorCode.CascadedPIDNotSupporteYet: 107>, 'AuxiliaryPIDNotSupportedYet': <ErrorCode.CascadedPIDNotSupporteYet: 107>, 'RemoteSensorsNotSupportedYet': <ErrorCode.RemoteSensorsNotSupportedYet: 108>, 'MotProfFirmThreshold': <ErrorCode.MotProfFirmThreshold: 109>, 'MotProfFirmThreshold2': <ErrorCode.MotProfFirmThreshold2: 110>, 'SimDeviceNotFound': <ErrorCode.SimDeviceNotFound: 200>, 'SimPhysicsTypeNotSupported': <ErrorCode.SimPhysicsTypeNotSupported: 201>, 'SimDeviceAlreadyExists': <ErrorCode.SimDeviceAlreadyExists: 202>}
    kAccessDenied: ctre._ctre.ErrorCode # value = <ErrorCode.kAccessDenied: -1014>
    kFailedSetup: ctre._ctre.ErrorCode # value = <ErrorCode.kFailedSetup: -1006>
    kFirmwareInvalidResponse: ctre._ctre.ErrorCode # value = <ErrorCode.kFirmwareInvalidResponse: -1015>
    kGeneralWinUsbError: ctre._ctre.ErrorCode # value = <ErrorCode.kGeneralWinUsbError: -1005>
    kInvalidClass: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidClass: -1002>
    kInvalidGuid: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidGuid: -1001>
    kInvalidInterface: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidInterface: -1000>
    kInvalidPath: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidPath: -1004>
    kInvalidProtocol: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidProtocol: -1003>
    kInvalidRespFormat: ctre._ctre.ErrorCode # value = <ErrorCode.kInvalidRespFormat: -1010>
    kListenFailed: ctre._ctre.ErrorCode # value = <ErrorCode.kListenFailed: -1007>
    kReceiveFailed: ctre._ctre.ErrorCode # value = <ErrorCode.kReceiveFailed: -1009>
    kSendFailed: ctre._ctre.ErrorCode # value = <ErrorCode.kSendFailed: -1008>
    kWinUsbGeneralError: ctre._ctre.ErrorCode # value = <ErrorCode.kWinUsbGeneralError: -1013>
    kWinUsbInitFailed: ctre._ctre.ErrorCode # value = <ErrorCode.kWinUsbInitFailed: -1011>
    kWinUsbQueryFailed: ctre._ctre.ErrorCode # value = <ErrorCode.kWinUsbQueryFailed: -1012>
    pass
class Faults():
    """
    All the faults available to motor controllers
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    @property
    def APIError(self) -> bool:
        """
        API error detected.  Make sure API and firmware versions are compatible.

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        API error detected.  Make sure API and firmware versions are compatible.
        """
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see ResetDuringEn

        :type: bool
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        """
        Not used, @see ResetDuringEn
        """
    @property
    def HardwareFailure(self) -> bool:
        """
        Device detects hardware failure

        :type: bool
        """
    @HardwareFailure.setter
    def HardwareFailure(self, arg0: bool) -> None:
        """
        Device detects hardware failure
        """
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus

        :type: bool
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        """
        Remote Sensor is no longer detected on bus
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase

        :type: bool
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        """
        Device detects its sensor is out of phase
        """
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed

        :type: bool
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        """
        Device's sensor overflowed
        """
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Motor Controller is under 6.5V
        """
    pass
class FeedbackDevice():
    """
    Choose the feedback device for a motor controller.
    Consult product specific documentation to determine what is available/supported.

    Members:

      QuadEncoder : Quadrature encoder

      IntegratedSensor : TalonFX supports an integrated sensor.

      Analog : Analog potentiometer/encoder

      Tachometer : Tachometer

      PulseWidthEncodedPosition : CTRE Mag Encoder in Absolute mode or
    any other device that uses PWM to encode its output

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.

      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.

      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Analog: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.Analog: 2>
    CTRE_MagEncoder_Absolute: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.PulseWidthEncodedPosition: 8>
    CTRE_MagEncoder_Relative: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.QuadEncoder: 0>
    IntegratedSensor: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.IntegratedSensor: 1>
    None_: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.None_: 14>
    PulseWidthEncodedPosition: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.PulseWidthEncodedPosition: 8>
    QuadEncoder: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.QuadEncoder: 0>
    RemoteSensor0: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.RemoteSensor1: 12>
    SensorDifference: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.SensorDifference: 10>
    SensorSum: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.SoftwareEmulatedSensor: 15>
    Tachometer: ctre._ctre.FeedbackDevice # value = <FeedbackDevice.Tachometer: 4>
    __members__: dict # value = {'QuadEncoder': <FeedbackDevice.QuadEncoder: 0>, 'IntegratedSensor': <FeedbackDevice.IntegratedSensor: 1>, 'Analog': <FeedbackDevice.Analog: 2>, 'Tachometer': <FeedbackDevice.Tachometer: 4>, 'PulseWidthEncodedPosition': <FeedbackDevice.PulseWidthEncodedPosition: 8>, 'SensorSum': <FeedbackDevice.SensorSum: 9>, 'SensorDifference': <FeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <FeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <FeedbackDevice.RemoteSensor1: 12>, 'None_': <FeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <FeedbackDevice.SoftwareEmulatedSensor: 15>, 'CTRE_MagEncoder_Absolute': <FeedbackDevice.PulseWidthEncodedPosition: 8>, 'CTRE_MagEncoder_Relative': <FeedbackDevice.QuadEncoder: 0>}
    pass
class FilterConfigUtil():
    """
    Util class to help with filter configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def filterConfigurationDifferent(settings: FilterConfiguration) -> bool: ...
    @staticmethod
    def remoteSensorDeviceIDDifferent(settings: FilterConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def remoteSensorSourceDifferent(settings: FilterConfiguration) -> bool: ...
    pass
class FilterConfiguration():
    """
    Configurations for filters
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of currently selected configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: string representation fo currently selected configs
        """
    @property
    def remoteSensorDeviceID(self) -> int:
        """
        Remote Sensor's device ID

        :type: int
        """
    @remoteSensorDeviceID.setter
    def remoteSensorDeviceID(self, arg0: int) -> None:
        """
        Remote Sensor's device ID
        """
    @property
    def remoteSensorSource(self) -> RemoteSensorSource:
        """
        The remote sensor device and signal type to bind.

        :type: RemoteSensorSource
        """
    @remoteSensorSource.setter
    def remoteSensorSource(self, arg0: RemoteSensorSource) -> None:
        """
        The remote sensor device and signal type to bind.
        """
    pass
class FollowerType():
    """
    Choose the type of follower

    Members:

      PercentOutput : Follow the percentOutput the master is using

      AuxOutput1 : Follow the auxiliary output the master is
    calculating. Used for 2-axis control.
    This typically means apply PID0 - PID1 from master.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    AuxOutput1: ctre._ctre.FollowerType # value = <FollowerType.AuxOutput1: 1>
    PercentOutput: ctre._ctre.FollowerType # value = <FollowerType.PercentOutput: 0>
    __members__: dict # value = {'PercentOutput': <FollowerType.PercentOutput: 0>, 'AuxOutput1': <FollowerType.AuxOutput1: 1>}
    pass
class BaseMotorController(IMotorController, IFollower):
    """
    Base motor controller features for all CTRE CAN motor controllers.
    """
    def __init__(self, deviceNumber: int, model: str, canbus: str = '') -> None: 
        """
        Constructor for motor controllers.

        :param arbId:  Device ID [0,62]
        :param model:  String model of device.
                       Examples: "Talon SRX", "Talon FX", "Victor SPX".
        :param canbus: Name of the CANbus; can be a SocketCAN interface (on Linux),
                       or a CANivore device name or serial number
        """
    def __repr__(self) -> str: ...
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode: 
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.

        :param periodMs: The transmit period in ms.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode: 
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears all sticky faults.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the allowable closed-loop error in the given parameter slot.

        :param slotIdx:                 Parameter slot for the constant.
        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
        :param timeoutMs:               Timeout value in ms. If nonzero, function will wait for
                                        config success and report an error if it times out.
                                        If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Polarity of the Auxiliary PID (PID1).

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :param invert:    If true, use inverted PID1 output polarity.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.

        :param slotIdx:    Parameter slot for the constant.
        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                           *                                            the magnitude will apply in both forward and reverse directions.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.

        :param slotIdx:    Parameter slot for the constant.
        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                           *                                            1 ms, maximum of 64 ms.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the closed-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.

        Alternatively you can use the configAllSettings routine.

        :param timeoutMs: Timeout value in ms. Function will generate error if config is
                          not successful within timeout.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)

        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.

        :param feedbackNotContinuous: True to disable the overflow tracking.
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param type:              Limit switch source. User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit enable.

        :param enable:    Forward Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit threhold.

        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter.

        :param paramIndex: Index of custom parameter [0,1].
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter.

        :param param:     Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param:         Parameter enumeration
        :param valueToSend:   Value to send to parameter
        :param valueReceived: Reference to integer to receive
        :param subValue:      SubValue of parameter
        :param ordinal:       Ordinal of parameter
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, ordinal: int, timeoutMs: int) -> typing.Tuple[ErrorCode, int, int]: ...
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.

        :param limitSwitchDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                      Timeout value in ms. If nonzero, function will wait for
                                               config success and report an error if it times out.
                                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the maximum integral accumulator in the given parameter slot.

        :param slotIdx:   Parameter slot for the constant.
        :param iaccum:    Value of the maximum integral accumulator (closed loop error
                          units X 1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.

        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                          second).
        :param timeoutMs:                 Timeout value in ms. If nonzero, function will wait for config
                                          success and report an error if it times out. If zero, no
                                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.

        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for config
                                    success and report an error if it times out. If zero, no
                                    blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryInterpolationEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the buffer, the motor controller can
        linearly interpolate additional trajectory points between the buffered
        points.  The time delta between these interpolated points is 1 ms.

        By default this feature is enabled.

        :param enable:    Whether to enable the trajectory point interpolation feature.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).

        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.

        :param baseTrajDurationMs: The base duration time of every trajectory point.
                                   This is summed with the trajectory points unique timeDur.
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.

        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for config
                              success and report an error if it times out. If zero, no
                              blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the output deadband percentage.

        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                                Pass 0.04 for 4% (factory default).
        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [0,+1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [-1,0]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the open-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward peak output percentage.

        :param percentOut: Desired peak output percentage. [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse peak output percentage.

        :param percentOut: Desired peak output percentage.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).

        :param pulseWidthPeriod_EdgesPerRot: edges per rotation
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).

        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg
        :param timeoutMs:                       Timeout value in ms. If nonzero, function will wait for
                                                config success and report an error if it times out.
                                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: sensors.CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param deviceID:           The device ID of the remote sensor device.
        :param remoteSensorSource: The remote sensor device and signal type to bind.
        :param remoteOrdinal:      0 for configuring Remote Sensor 0,
                                   1 for configuring Remote Sensor 1
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param canCoderRef:   CANCoder device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param talonRef:      Talon device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configRemoteFeedbackFilter(self, talonRef: BaseTalon, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.

        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral
        :param timeoutMs:                                 Timeout value in ms. If nonzero, function will wait for
                                                          config success and report an error if it times out.
                                                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param type:              Limit switch source. User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit enable.

        :param enable:    Reverse Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit threshold.

        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.

        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.

        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                            *                                           Resolution is 1/(2^16).  Cannot be 0.
        :param pidIdx:      0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: RemoteFeedbackDevice, timeoutMs: int = 0) -> ErrorCode: ...
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.

        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.

        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.

        :param softLimitDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period over which velocity measurements are taken.

        :param period:    Desired period for the velocity measurement. @see
                          #SensorVelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another value
                           is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Voltage Compensation saturation voltage.

        :param voltage:   This is the max voltage to apply to the hbridge when voltage
                          compensation is enabled.  For example, if 10 (volts) is specified
                          and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                          then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the voltage measurement filter.

        :param filterWindowSamples: Number of samples in the rolling average of voltage
                                    measurement.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :param slotIdx:   Parameter slot for the constant.
        :param izone:     Value of the Integral Zone constant (closed loop error units X
                          1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'D' constant in the given parameter slot.

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the D constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'F' constant in the given parameter slot.

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the F constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the I constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the P constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configureSlot(self, slot: SlotConfiguration, slotIdx: int, timeoutMs: int) -> ErrorCode: 
        """
        Configures all slot persistant settings

        :param slot:      Object with all of the slot persistant settings
        :param slotIdx:   Index of slot to configure
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllMotControllers() -> None: 
        """
        Destructs all motor controller objects
        """
    def enableVoltageCompensation(self, enable: bool) -> None: 
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.

        Be sure to configure the saturation voltage before enabling this.

        :param enable: Enable state of voltage compensation.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController) -> None: 
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.

        :param masterToFollow: *                                                Motor Controller object to follow.
        :param followerType:   *                                                Type of following control.  Use AuxOutput1 to follow the master
                               *                                                device's auxiliary output 1.
                               *                                                Use PercentOutput for standard follower mode.

        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController, followerType: FollowerType) -> None: ...
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory target position using
        MotionMagic/MotionProfile control modes.

        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory target velocity using
        MotionMagic/MotionProfile control modes.

        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int: ...
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> float: 
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.

        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).

        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).

        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.

        See Phoenix-Documentation information on units.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float: 
        """
        Gets the current target of a given closed loop.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode: 
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int: 
        """
        Returns the Device ID

        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float: 
        """
        Gets the derivative of the closed-loop error.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode: 
        """
        Polls the various fault flags.

        :param toFill: Caller's object to fill with latest fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getFilterConfigs(self, Filter: FilterConfiguration, ordinal: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all filter persistant settings.

        :param Filter:    Object with all of the filter persistant settings
        :param ordinal:   0 for remote sensor 0 and 1 for remote sensor 1.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getHandle(self) -> capsule: 
        """
        :returns: CCI handle for child classes.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float: 
        """
        Gets the iaccum value.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool: 
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode: 
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.

        The members are filled, as follows...

        *       topBufferRem:   The available empty slots in the trajectory buffer.
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the
        low-level buffer, allowing the motor controller to act on them.

        *       topBufferRem: The number of points in the top trajectory buffer.

        *       btmBufferCnt: The number of points in the low level controller buffer.

        *       hasUnderrun:    Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().

        *       isUnderrun:             This is set if controller needs to shift a point from its buffer into
        *                                       the active trajectory point however
        *                                       the buffer is empty.
        *                                       This gets cleared automatically when is resolved.

        *       activePointValid:       True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.

        *       isLast: is set/cleared based on the MP executer's current
        trajectory point's IsLast value.  This assumes
        IsLast was set when PushMotionProfileTrajectory
        was used to insert the currently processed trajectory
        point.

        *       profileSlotSelect: The currently processed trajectory point's
        selected slot.  This can differ in the currently selected slot used
        for Position and Velocity servo modes

        *       outputEnable:           The current output mode of the motion profile
        *                                               executer (disabled, enabled, or hold).  When changing the set()
        *                                               value in MP mode, it's important to check this signal to
        *                                               confirm the change takes effect before interacting with the top buffer.

        :param statusToFill: Caller supplied object to fill.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int: 
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float: 
        """
        Gets the output percentage of the motor controller.

        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float: 
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> float: 
        """
        Get the selected sensor position (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
                       Phoenix-Documentation for how to interpret.

        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> float: 
        """
        Get the selected sensor velocity.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getSlotConfigs(self, slot: SlotConfiguration, slotIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all slot persistant settings.

        :param slot:      Object with all of the slot persistant settings
        :param slotIdx:   Parameter slot for the constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode: 
        """
        Polls the various sticky fault flags.

        :param toFill: Caller's object to fill with latest sticky fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float: 
        """
        Gets the temperature of the motor controller.

        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileFinished(self) -> bool: 
        """
        Determine if running MP is complete.
        This requires using the StartMotionProfile routine to start the MP.
        That is because managing the trajectory points is now done in a background thread (if StartMotionProfile is called).

        If calling application uses the legacy API  (more-complex buffering API) from previous years, than this API will
        not return true.

        :returns: true if MP was started using StartMotionProfile, and it has completed execution (MPE is now in "hold").
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool: 
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool: 
        """
        Returns the enable state of Voltage Compensation that the caller has set.

        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None: 
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None: 
        """
        Sets the enable state for limit switches.

        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None: 
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.

        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None: 
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).

        targPos:  servo position in sensor units.
        *               targVel:  velocity to feed-forward in sensor units
        per 100ms.
        profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
        *                                                  as the Kv constant for velocity feed-forward. Typically this is hardcoded
        *                                                  to the a particular slot, but you are free gain schedule if need be.
        *                                                  Choose from [0,3]
        *               profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
        *                                                  This only has impact during MotionProfileArc Control mode.
        *                                                  Choose from [0,1].
        isLastPoint  set to nonzero to signal motor controller to keep processing this
        trajectory point, instead of jumping to the next one
        when timeDurMs expires.  Otherwise MP executer will
        eventually see an empty buffer after the last point
        expires, causing it to assert the IsUnderRun flag.
        However this may be desired if calling application
        never wants to terminate the MP.
        *               zeroPos  set to nonzero to signal motor controller to "zero" the selected
        position sensor before executing this trajectory point.
        Typically the first point should have this set only thus
        allowing the remainder of the MP positions to be relative to
        zero.
        *               timeDur Duration to apply this trajectory pt.
        This time unit is ADDED to the exising base time set by
        configMotionProfileTrajectoryPeriod().

        :param trajPt: to push into buffer.
                       The members should be filled in with these values...

        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode: 
        """
        Selects which profile slot to use for closed-loop control.

        :param slotIdx: Profile slot to select.
        :param pidIdx:  0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        *       Standard Driving Example:
        *       _talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *       _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.

        Arcade Drive Example:
        *               _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.

        :param iaccum:    Value to set for the integral accumulator (closed loop error
                          units X 1ms).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller.

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.

        :param invert: Invert state to set.

        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setNeutralMode(self, neutralMode: NeutralMode) -> None: 
        """
        Sets the mode of operation during neutral throttle output.

        :param neutralMode: The desired mode of operation when the Controller output
                            throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: float, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets the sensor position to the given value.

        :param sensorPos: Position to set for the selected sensor (in raw sensor units).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None: 
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.

        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    def startMotionProfile(self, stream: BufferedTrajectoryPointStream, minBufferedPts: int, motionProfControlMode: ControlMode) -> ErrorCode: 
        """
        Simple one-shot firing of a complete MP.
        Starting in 2019, MPs can be fired by building a Buffered Trajectory Point Stream, and calling this routine.

        Once called, the motor controller software will automatically ...
        [1] Clear the firmware buffer of trajectory points.
        [2] Clear the underrun flags
        [3] Reset an index within the Buffered Trajectory Point Stream (so that the same profile can be run again and again).
        [4] Start a background thread to manage MP streaming (if not already running).
        [5a] If current control mode already matches motionProfControlMode, set MPE Output to "Hold".
        [5b] If current control mode does not matches motionProfControlMode, apply motionProfControlMode and set MPE Output to "Disable".
        [6] Stream the trajectory points into the device's firmware buffer.
        [7] Once motor controller has at least minBufferedPts worth in the firmware buffer, MP will automatically start (MPE Output set to "Enable").
        [8] Wait until MP finishes, then transitions the Motion Profile Executor's output to "Hold".
        [9] IsMotionProfileFinished() will now return true.

        Calling application can use IsMotionProfileFinished() to determine when internal state machine reaches [7].
        Calling application can cancel MP by calling set().  Otherwise do not call set() until MP has completed.

        The legacy API from previous years requires the calling application to pass points via the ProcessMotionProfileBuffer and PushMotionProfileTrajectory.
        This is no longer required if using this StartMotionProfile/IsMotionProfileFinished API.

        :param stream:                A buffer that will be used to stream the trajectory points.  Caller can fill this container with the entire trajectory point, regardless of size.
        :param minBufferedPts:        Minimum number of firmware buffered points before starting MP.
                                      *                                                 Do not exceed device's firmware buffer capacity or MP will never fire (120 for Motion Profile, or 60 for Motion Profile Arc).
                                      *                                                 Recommendation value for this would be five to ten samples depending on timeDur of the trajectory point.
        :param motionProfControlMode: Pass MotionProfile or MotionProfileArc.

        :returns: nonzero error code if operation fails.
        """
    def valueUpdated(self) -> None: 
        """
        When master makes a device, this routine is called to signal the update.
        """
    pass
class IGadgeteerUartClient():
    """
    Interface for uart gadgeteer devices
    """
    class GadgeteerConnection():
        """
        Method of connection to gadgeteer

        Members:

          NotConnected : Device not connected

          Connecting : Device in process of connecting

          Connected : Device is connected
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        Connected: ctre._ctre.IGadgeteerUartClient.GadgeteerConnection # value = <GadgeteerConnection.Connected: 2>
        Connecting: ctre._ctre.IGadgeteerUartClient.GadgeteerConnection # value = <GadgeteerConnection.Connecting: 1>
        NotConnected: ctre._ctre.IGadgeteerUartClient.GadgeteerConnection # value = <GadgeteerConnection.NotConnected: 0>
        __members__: dict # value = {'NotConnected': <GadgeteerConnection.NotConnected: 0>, 'Connecting': <GadgeteerConnection.Connecting: 1>, 'Connected': <GadgeteerConnection.Connected: 2>}
        pass
    class GadgeteerProxyType():
        """
        Device connected to gadgeteer

        Members:

          General : General Gadgeteer Proxy

          Pigeon : Pigeon connected to gadgeteer

          PC_HERO : HERO connected to gadgeteer
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        General: ctre._ctre.IGadgeteerUartClient.GadgeteerProxyType # value = <GadgeteerProxyType.General: 0>
        PC_HERO: ctre._ctre.IGadgeteerUartClient.GadgeteerProxyType # value = <GadgeteerProxyType.PC_HERO: 2>
        Pigeon: ctre._ctre.IGadgeteerUartClient.GadgeteerProxyType # value = <GadgeteerProxyType.Pigeon: 1>
        __members__: dict # value = {'General': <GadgeteerProxyType.General: 0>, 'Pigeon': <GadgeteerProxyType.Pigeon: 1>, 'PC_HERO': <GadgeteerProxyType.PC_HERO: 2>}
        pass
    class GadgeteerUartStatus():
        """
        The status of the gadgeteer device
        """
        def __init__(self) -> None: ...
        @property
        def bitrate(self) -> int:
            """
            Bitrate of connection

            :type: int
            """
        @bitrate.setter
        def bitrate(self, arg0: int) -> None:
            """
            Bitrate of connection
            """
        @property
        def conn(self) -> IGadgeteerUartClient.GadgeteerConnection:
            """
            Connection status

            :type: IGadgeteerUartClient.GadgeteerConnection
            """
        @conn.setter
        def conn(self, arg0: IGadgeteerUartClient.GadgeteerConnection) -> None:
            """
            Connection status
            """
        @property
        def resetCount(self) -> int:
            """
            Number of resets that have happened

            :type: int
            """
        @resetCount.setter
        def resetCount(self, arg0: int) -> None:
            """
            Number of resets that have happened
            """
        @property
        def type(self) -> IGadgeteerUartClient.GadgeteerProxyType:
            """
            Type of gadgeteer

            :type: IGadgeteerUartClient.GadgeteerProxyType
            """
        @type.setter
        def type(self, arg0: IGadgeteerUartClient.GadgeteerProxyType) -> None:
            """
            Type of gadgeteer
            """
        pass
    def __init__(self) -> None: ...
    def getGadgeteerStatus(self, status: IGadgeteerUartClient.GadgeteerUartStatus) -> int: 
        """
        Gets gadgeteer status

        :param status: status object to fill

        :returns: ErrorCode
        """
    @staticmethod
    @typing.overload
    def toString(gc: IGadgeteerUartClient.GadgeteerConnection) -> str: 
        """
        Gets the string representation of GadgeteerProxyType

        :param gpt: GadgeteerProxyType to get the string of

        :returns: strnig representation of GadgeteerProxyType

        Gets the string representation of GadgeteerConnection

        :param gc: GadgeteerConnection to get the string of

        :returns: strnig representation of GadgeteerConnection
        """
    @staticmethod
    @typing.overload
    def toString(gpt: IGadgeteerUartClient.GadgeteerProxyType) -> str: ...
    pass
class IInvertable():
    """
    Interface for invertable objects
    """
    def __init__(self) -> None: ...
    def getInverted(self) -> bool: 
        """
        :returns: invert setting of output.
        """
    def setInverted(self, invert: bool) -> None: 
        """
        Inverts the output of the object

        :param invert: Invert state to set.
        """
    pass
class ILoopable():
    """
    Interface for loopable objects
    """
    def __init__(self) -> None: ...
    def isDone(self) -> bool: 
        """
        :returns: true if object is done
        """
    def onLoop(self) -> None: 
        """
        Function called every loop
        """
    def onStart(self) -> None: 
        """
        Function called when object starts
        """
    def onStop(self) -> None: 
        """
        Function called when object stops
        """
    pass
class IMotorControllerEnhanced(IMotorController, IFollower):
    """
    Interface for enhanced motor controllers
    """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the supply-side current limit.

        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: VelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period over which velocity measurements are taken.

        :param period:    Desired period for the velocity measurement. @see
                          com.ctre.phoenix.motorcontrol.VelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another value
                           is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float: 
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.

        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]

        :returns: The output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class BaseTalon(BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int, model: str, canbus: str = '') -> None: 
        """
        Constructor for a Talon

        :param deviceNumber: CAN Device ID of BaseTalon
        :param canbus:       Name of the CANbus; can be a SocketCAN interface (on Linux),
                             or a CANivore device name or serial number
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source.
                                  User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                                  matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for
                                  config success and report an error if it times out.
                                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source.
                                  User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                                  matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for
                                  config success and report an error if it times out.
                                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: ...
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.

        :param period:    Desired period for the velocity measurement. @see
                          #SensorVelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another
                           value is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float: 
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.

        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]

        :returns: The output current (in amps).
        """
    def getStatorCurrent(self) -> float: 
        """
        Gets the stator/output current of the motor controller.

        :returns: The stator/output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    def getSupplyCurrent(self) -> float: 
        """
        Gets the supply/input current of the motor controller.

        :returns: The supply/input current (in amps).
        """
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.

        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class IOutputSignal():
    """
    Interface for output signals
    """
    def __init__(self) -> None: ...
    def set(self, value: float) -> None: 
        """
        Set signal

        :param value: value to set
        """
    pass
class IProcessable():
    """
    Interface for processable objects
    """
    def __init__(self) -> None: ...
    def process(self) -> None: 
        """
        This function is called when a process occurs
        """
    pass
class InvertType():
    """
    Choose the invert type of the motor controller.
    None is the equivalent of SetInverted(false), where positive request yields positive voltage on M+.
    InvertMotorOutput is the equivelant of SetInverted(true), where positive request yields positive voltage on M-.
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.

    Members:

      None_ : Same as SetInverted(false)

      InvertMotorOutput : Same as SetInverted(true)

      FollowMaster : Follow the invert of the master this MC is following.

      OpposeMaster : Opposite of the invert of the master this MC is following.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    FollowMaster: ctre._ctre.InvertType # value = <InvertType.FollowMaster: 2>
    InvertMotorOutput: ctre._ctre.InvertType # value = <InvertType.InvertMotorOutput: 1>
    None_: ctre._ctre.InvertType # value = <InvertType.None_: 0>
    OpposeMaster: ctre._ctre.InvertType # value = <InvertType.OpposeMaster: 3>
    __members__: dict # value = {'None_': <InvertType.None_: 0>, 'InvertMotorOutput': <InvertType.InvertMotorOutput: 1>, 'FollowMaster': <InvertType.FollowMaster: 2>, 'OpposeMaster': <InvertType.OpposeMaster: 3>}
    pass
class LimitSwitchNormal():
    """
    Choose whether the limit switch is normally
    open or normally closed

    Members:

      NormallyOpen : Limit Switch is tripped when
    the circuit is closed

      NormallyClosed : Limit Switch is tripped when
    the circuit is open

      Disabled : Limit switch is disabled
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Disabled: ctre._ctre.LimitSwitchNormal # value = <LimitSwitchNormal.Disabled: 2>
    NormallyClosed: ctre._ctre.LimitSwitchNormal # value = <LimitSwitchNormal.NormallyClosed: 1>
    NormallyOpen: ctre._ctre.LimitSwitchNormal # value = <LimitSwitchNormal.NormallyOpen: 0>
    __members__: dict # value = {'NormallyOpen': <LimitSwitchNormal.NormallyOpen: 0>, 'NormallyClosed': <LimitSwitchNormal.NormallyClosed: 1>, 'Disabled': <LimitSwitchNormal.Disabled: 2>}
    pass
class LimitSwitchRoutines():
    """
    Class to handle various functions regarding limit switches
    """
    @staticmethod
    def isRemote(limitSwitchSource: LimitSwitchSource) -> bool: 
        """
        Checks if a limit switch is one of the remote values
        (i.e. RemoteTalonSRX or RemoteCANifier)

        :param limitSwitchSource: limitSwitchSource to check

        :returns: true if it's a remote limit switch source
        """
    @staticmethod
    def promote(limitSwitchSource: RemoteLimitSwitchSource) -> LimitSwitchSource: 
        """
        Takes a RemoteLimitSwitchSource and brings it up to a LimitSwitchSource

        :param limitSwitchSource: LimitSwitchSource to promote

        :returns: promoted limitSwitchSource
        """
    pass
class LimitSwitchSource():
    """
    Limit switch source enum

    Members:

      FeedbackConnector : Limit switch directly connected to motor controller

      RemoteTalon : Use Limit switch connected to Talon on CAN

      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN

      RemoteCANifier : User Limit switch connected to CANifier

      Deactivated : Don't use a limit switch
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Deactivated: ctre._ctre.LimitSwitchSource # value = <LimitSwitchSource.Deactivated: 3>
    FeedbackConnector: ctre._ctre.LimitSwitchSource # value = <LimitSwitchSource.FeedbackConnector: 0>
    RemoteCANifier: ctre._ctre.LimitSwitchSource # value = <LimitSwitchSource.RemoteCANifier: 2>
    RemoteTalon: ctre._ctre.LimitSwitchSource # value = <LimitSwitchSource.RemoteTalon: 1>
    RemoteTalonSRX: ctre._ctre.LimitSwitchSource # value = <LimitSwitchSource.RemoteTalon: 1>
    __members__: dict # value = {'FeedbackConnector': <LimitSwitchSource.FeedbackConnector: 0>, 'RemoteTalon': <LimitSwitchSource.RemoteTalon: 1>, 'RemoteTalonSRX': <LimitSwitchSource.RemoteTalon: 1>, 'RemoteCANifier': <LimitSwitchSource.RemoteCANifier: 2>, 'Deactivated': <LimitSwitchSource.Deactivated: 3>}
    pass
class MotionProfileStatus():
    """
    Motion Profile Status
    This is simply a data transer object.
    """
    def __init__(self) -> None: ...
    @property
    def activePointValid(self) -> bool:
        """
        True if the active trajectory point is not empty, false otherwise.
        The members in activePoint are only valid if this signal is set.

        :type: bool
        """
    @activePointValid.setter
    def activePointValid(self, arg0: bool) -> None:
        """
        True if the active trajectory point is not empty, false otherwise.
        The members in activePoint are only valid if this signal is set.
        """
    @property
    def btmBufferCnt(self) -> int:
        """
        The number of points in the low level Talon/Victor buffer.

        :type: int
        """
    @btmBufferCnt.setter
    def btmBufferCnt(self, arg0: int) -> None:
        """
        The number of points in the low level Talon/Victor buffer.
        """
    @property
    def hasUnderrun(self) -> bool:
        """
        Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        @see clearMotionProfileHasUnderrun()

        :type: bool
        """
    @hasUnderrun.setter
    def hasUnderrun(self, arg0: bool) -> None:
        """
        Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        @see clearMotionProfileHasUnderrun()
        """
    @property
    def isLast(self) -> bool:
        """
        True if the active trajectory point is the last point of the profile

        :type: bool
        """
    @isLast.setter
    def isLast(self, arg0: bool) -> None:
        """
        True if the active trajectory point is the last point of the profile
        """
    @property
    def isUnderrun(self) -> bool:
        """
        This is set if Talon/Victor needs to shift a point from its buffer into
        the active trajectory point however the buffer is empty. This gets cleared
        automatically when is resolved.

        :type: bool
        """
    @isUnderrun.setter
    def isUnderrun(self, arg0: bool) -> None:
        """
        This is set if Talon/Victor needs to shift a point from its buffer into
        the active trajectory point however the buffer is empty. This gets cleared
        automatically when is resolved.
        """
    @property
    def outputEnable(self) -> SetValueMotionProfile:
        """
        The current output mode of the motion profile executer (disabled, enabled, or hold).
        When changing the set() value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.

        :type: SetValueMotionProfile
        """
    @outputEnable.setter
    def outputEnable(self, arg0: SetValueMotionProfile) -> None:
        """
        The current output mode of the motion profile executer (disabled, enabled, or hold).
        When changing the set() value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.
        """
    @property
    def profileSlotSelect0(self) -> int:
        """
        The selected PID[0] profile slot of current profile

        :type: int
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        """
        The selected PID[0] profile slot of current profile
        """
    @property
    def profileSlotSelect1(self) -> int:
        """
        The selected auxiliary PID[1] profile slot of current profile

        :type: int
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        """
        The selected auxiliary PID[1] profile slot of current profile
        """
    @property
    def timeDurMs(self) -> int:
        """
        The applied duration of the active trajectory point

        :type: int
        """
    @timeDurMs.setter
    def timeDurMs(self, arg0: int) -> None:
        """
        The applied duration of the active trajectory point
        """
    @property
    def topBufferCnt(self) -> int:
        """
        The number of points in the top trajectory buffer.

        :type: int
        """
    @topBufferCnt.setter
    def topBufferCnt(self, arg0: int) -> None:
        """
        The number of points in the top trajectory buffer.
        """
    @property
    def topBufferRem(self) -> int:
        """
        The available empty slots in the trajectory buffer.

        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the Talon's
        low-level buffer, allowing the Talon to act on them.

        :type: int
        """
    @topBufferRem.setter
    def topBufferRem(self, arg0: int) -> None:
        """
        The available empty slots in the trajectory buffer.

        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the Talon's
        low-level buffer, allowing the Talon to act on them.
        """
    pass
class MotorCommutation():
    """
    Choose the type of motor commutation.  This is for products that support selectable commutation strategies.

    Members:

      Trapezoidal : Trapezoidal Commutation
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Trapezoidal: ctre._ctre.MotorCommutation # value = <MotorCommutation.Trapezoidal: 0>
    __members__: dict # value = {'Trapezoidal': <MotorCommutation.Trapezoidal: 0>}
    pass
class MovingAverage():
    """
    Class to calculate the rolling average of a signal
    """
    def __init__(self, capacity: int) -> None: 
        """
        Constructor for a MovingAverage Object

        :param capacity: maximum number of items this will hold
        """
    def clear(self) -> None: 
        """
        Clears all data points
        """
    def getCount(self) -> int: 
        """
        :returns: the count of the items
        """
    def getSum(self) -> float: 
        """
        :returns: the sum of the items
        """
    def pop(self) -> None: 
        """
        Pull out oldest item
        """
    def process(self, input: float) -> float: 
        """
        Add input & calculate average

        :param input: Value to add

        :returns: new average
        """
    def push(self, d: float) -> None: 
        """
        Add new item

        :param d: item to add
        """
    pass
class NeutralMode():
    """
    Choose the neutral mode for a motor controller

    Members:

      EEPROMSetting : Use the NeutralMode that is set in the MC's persistent storage.

      Coast : When commanded to neutral, motor leads are set to high-impedance, allowing mechanism to coast.

      Brake : When commanded to neutral, motor leads are commonized electrically to reduce motion.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Brake: ctre._ctre.NeutralMode # value = <NeutralMode.Brake: 2>
    Coast: ctre._ctre.NeutralMode # value = <NeutralMode.Coast: 1>
    EEPROMSetting: ctre._ctre.NeutralMode # value = <NeutralMode.EEPROMSetting: 0>
    __members__: dict # value = {'EEPROMSetting': <NeutralMode.EEPROMSetting: 0>, 'Coast': <NeutralMode.Coast: 1>, 'Brake': <NeutralMode.Brake: 2>}
    pass
class Orchestra():
    """
    An Orchestra is used to play music through Talon FX motor controllers.
    It uses a "Chirp" (.chrp) music file that can be generated using Phoenix Tuner.

    Chirp files are generated from standard MIDI files.
    Each Talon FX can only play a single track within the music file.
    For multi-track files, multiple Talon FXs are needed.
    ie, The first track will be played through the first Talon FX added,
    the second track will be played through the second Talon FX added, etc.

    Any Chirp file located in the src/main/deploy directory of your FRC project
    will automatically be copied to the roboRIO on code deploy.

    To use the Orchestra:
    - Add the Talon FXs to be used as instruments
    - Load the Chirp file to be played using the LoadMusic routine.

    Once ready, the Orchestra can be controlled using standard
    play/pause/stop routines.

    New music files can be loaded at any time.

    The robot must be enabled to play music.

    Calling set on any of the TalonFX instruments while the orchestra is
    playing will pause the orchestra.
    """
    def __init__(self) -> None: 
        """
        Constructor for an Orchestra Object.
        Call AddInstrument after this to add the instruments.
        """
    def addInstrument(self, instrument: TalonFX) -> ErrorCode: 
        """
        Adds another instrument to the orchestra.

        :param instrument: TalonFX to add to orchestra

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearInstruments(self) -> ErrorCode: 
        """
        Clears all instruments in the orchestra.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getCurrentTime(self) -> int: 
        """
        :returns: The current timestamp of the music file (playing or paused) in milliseconds.
                  The timestamp will reset to zero whenever LoadMusic() or Stop() is called.
                  If IsPlaying() returns false, this routine can be used to determine if music is stopped or paused.
        """
    def isPlaying(self) -> bool: 
        """
        Returns whether the current track is actively playing or not

        :returns: True if playing, false otherwise
        """
    def loadMusic(self, filePath: str) -> ErrorCode: 
        """
        Loads a Chirp file at the specified file path.

        If the Chirp file is inside your "src/main/deploy" directory
        this file will be automatically deployed to a default directory in
        the RoboRIO when you deploy code. For these files, the name and file
        extension is sufficient.

        Use Tuner to create a Chirp file.

        :param filepath: The path to the Chirp File.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def pause(self) -> ErrorCode: 
        """
        Pauses the music file that's loaded.
        This saves the current position in the track, so it can be resumed later.
        Pausing while stopped is an invalid request.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def play(self) -> ErrorCode: 
        """
        Plays the music file that's loaded.
        If the player is paused, this will resume.
        This will also resume a song if the orchestra was interrupted.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def stop(self) -> ErrorCode: 
        """
        Stops the music file that's loaded.
        This resets the current position in the track to the start.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    pass
class ParamEnum():
    """
    Signal enumeration for generic signal access.

    Members:

      eOnBoot_BrakeMode

      eQuadFilterEn

      eQuadIdxPolarity

      eMotionProfileHasUnderrunErr

      eMotionProfileTrajectoryPointDurationMs

      eMotionProfileTrajectoryInterpolDis

      eStatusFramePeriod

      eOpenloopRamp

      eClosedloopRamp

      eNeutralDeadband

      ePeakPosOutput

      eNominalPosOutput

      ePeakNegOutput

      eNominalNegOutput

      eProfileParamSlot_P

      eProfileParamSlot_I

      eProfileParamSlot_D

      eProfileParamSlot_F

      eProfileParamSlot_IZone

      eProfileParamSlot_AllowableErr

      eProfileParamSlot_MaxIAccum

      eProfileParamSlot_PeakOutput

      eClearPositionOnLimitF

      eClearPositionOnLimitR

      eClearPositionOnQuadIdx

      eSampleVelocityPeriod

      eSampleVelocityWindow

      eFeedbackSensorType

      eSelectedSensorPosition

      eFeedbackNotContinuous

      eRemoteSensorSource

      eRemoteSensorDeviceID

      eSensorTerm

      eRemoteSensorClosedLoopDisableNeutralOnLOS

      ePIDLoopPolarity

      ePIDLoopPeriod

      eSelectedSensorCoefficient

      eForwardSoftLimitThreshold

      eReverseSoftLimitThreshold

      eForwardSoftLimitEnable

      eReverseSoftLimitEnable

      eNominalBatteryVoltage

      eBatteryVoltageFilterSize

      eContinuousCurrentLimitAmps

      ePeakCurrentLimitMs

      ePeakCurrentLimitAmps

      eCurrLimit_Amps

      eCurrThres_Amps

      eCurrEnable

      eCurrThres_Ms

      eClosedLoopIAccum

      eCustomParam

      eStickyFaults

      eAnalogPosition

      eQuadraturePosition

      ePulseWidthPosition

      eIntegratedSensor

      eMotMag_Accel

      eMotMag_VelCruise

      eMotMag_SCurveLevel

      eLimitSwitchSource

      eLimitSwitchNormClosedAndDis

      eLimitSwitchDisableNeutralOnLOS

      eLimitSwitchRemoteDevID

      eSoftLimitDisableNeutralOnLOS

      ePulseWidthPeriod_EdgesPerRot

      ePulseWidthPeriod_FilterWindowSz

      eYawOffset

      eCompassOffset

      eBetaGain

      eEnableCompassFusion

      eGyroNoMotionCal

      eEnterCalibration

      eFusedHeadingOffset

      eStatusFrameRate

      eAccumZ

      eTempCompDisable

      eMotionMeas_tap_threshX

      eMotionMeas_tap_threshY

      eMotionMeas_tap_threshZ

      eMotionMeas_tap_count

      eMotionMeas_tap_time

      eMotionMeas_tap_time_multi

      eMotionMeas_shake_reject_thresh

      eMotionMeas_shake_reject_time

      eMotionMeas_shake_reject_timeout

      eUnitString

      eFeedbackTimeBase

      eDefaultConfig

      eFastWriteCount

      eWriteCount

      eReserved1

      eMotorCommutation

      eSensorInitStrategy

      eSensorDirection

      eMagnetOffset

      eSensorSync

      eAbsSensorRange

      eChangeCompassUse

      eRestartKalman

      eAccNoiseAmplificationGain

      eMagNoiseAmplificationGain

      eGyrNoiseAmplificationGain

      eMaxAccKg

      eMaxMagKg

      eGyroBias

      eAccelOffsets

      eMagCal

      eMagCalSlot

      eMagCalRunning

      eGyrResolution

      eAccelKalmanBiasGain

      eMagKalmanBiasGain

      eTempCalRunning

      eApplyTempCal

      eClearTempCal

      eDontRunThermComp

      eChangeHeatOutput

      eSetNoMotionCalDisable

      eClearMagCal

      eSetGyrSensitivity

      eSetVsenseScalar

      eConfigMountPoseYaw

      eConfigMountPosePitch

      eConfigMountPoseRoll

      eConfigAccelScalar

      eConfigGyroScalarX

      eConfigGyroScalarY

      eConfigGyroScalarZ

      eCustomParam0

      eCustomParam1

      eLEDStripType

      eLossOfSignalBehavior

      eBrightnessCoefficient

      eStatusLedState

      eVBatOutput

      eV5Enabled
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    __members__: dict # value = {'eOnBoot_BrakeMode': <ParamEnum.eOnBoot_BrakeMode: 31>, 'eQuadFilterEn': <ParamEnum.eQuadFilterEn: 91>, 'eQuadIdxPolarity': <ParamEnum.eQuadIdxPolarity: 108>, 'eMotionProfileHasUnderrunErr': <ParamEnum.eMotionProfileHasUnderrunErr: 119>, 'eMotionProfileTrajectoryPointDurationMs': <ParamEnum.eMotionProfileTrajectoryPointDurationMs: 120>, 'eMotionProfileTrajectoryInterpolDis': <ParamEnum.eMotionProfileTrajectoryInterpolDis: 121>, 'eStatusFramePeriod': <ParamEnum.eStatusFramePeriod: 300>, 'eOpenloopRamp': <ParamEnum.eOpenloopRamp: 301>, 'eClosedloopRamp': <ParamEnum.eClosedloopRamp: 302>, 'eNeutralDeadband': <ParamEnum.eNeutralDeadband: 303>, 'ePeakPosOutput': <ParamEnum.ePeakPosOutput: 305>, 'eNominalPosOutput': <ParamEnum.eNominalPosOutput: 306>, 'ePeakNegOutput': <ParamEnum.ePeakNegOutput: 307>, 'eNominalNegOutput': <ParamEnum.eNominalNegOutput: 308>, 'eProfileParamSlot_P': <ParamEnum.eProfileParamSlot_P: 310>, 'eProfileParamSlot_I': <ParamEnum.eProfileParamSlot_I: 311>, 'eProfileParamSlot_D': <ParamEnum.eProfileParamSlot_D: 312>, 'eProfileParamSlot_F': <ParamEnum.eProfileParamSlot_F: 313>, 'eProfileParamSlot_IZone': <ParamEnum.eProfileParamSlot_IZone: 314>, 'eProfileParamSlot_AllowableErr': <ParamEnum.eProfileParamSlot_AllowableErr: 315>, 'eProfileParamSlot_MaxIAccum': <ParamEnum.eProfileParamSlot_MaxIAccum: 316>, 'eProfileParamSlot_PeakOutput': <ParamEnum.eProfileParamSlot_PeakOutput: 317>, 'eClearPositionOnLimitF': <ParamEnum.eClearPositionOnLimitF: 320>, 'eClearPositionOnLimitR': <ParamEnum.eClearPositionOnLimitR: 321>, 'eClearPositionOnQuadIdx': <ParamEnum.eClearPositionOnQuadIdx: 322>, 'eSampleVelocityPeriod': <ParamEnum.eSampleVelocityPeriod: 325>, 'eSampleVelocityWindow': <ParamEnum.eSampleVelocityWindow: 326>, 'eFeedbackSensorType': <ParamEnum.eFeedbackSensorType: 330>, 'eSelectedSensorPosition': <ParamEnum.eSelectedSensorPosition: 331>, 'eFeedbackNotContinuous': <ParamEnum.eFeedbackNotContinuous: 332>, 'eRemoteSensorSource': <ParamEnum.eRemoteSensorSource: 333>, 'eRemoteSensorDeviceID': <ParamEnum.eRemoteSensorDeviceID: 334>, 'eSensorTerm': <ParamEnum.eSensorTerm: 335>, 'eRemoteSensorClosedLoopDisableNeutralOnLOS': <ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS: 336>, 'ePIDLoopPolarity': <ParamEnum.ePIDLoopPolarity: 337>, 'ePIDLoopPeriod': <ParamEnum.ePIDLoopPeriod: 338>, 'eSelectedSensorCoefficient': <ParamEnum.eSelectedSensorCoefficient: 339>, 'eForwardSoftLimitThreshold': <ParamEnum.eForwardSoftLimitThreshold: 340>, 'eReverseSoftLimitThreshold': <ParamEnum.eReverseSoftLimitThreshold: 341>, 'eForwardSoftLimitEnable': <ParamEnum.eForwardSoftLimitEnable: 342>, 'eReverseSoftLimitEnable': <ParamEnum.eReverseSoftLimitEnable: 343>, 'eNominalBatteryVoltage': <ParamEnum.eNominalBatteryVoltage: 350>, 'eBatteryVoltageFilterSize': <ParamEnum.eBatteryVoltageFilterSize: 351>, 'eContinuousCurrentLimitAmps': <ParamEnum.eContinuousCurrentLimitAmps: 360>, 'ePeakCurrentLimitMs': <ParamEnum.ePeakCurrentLimitMs: 361>, 'ePeakCurrentLimitAmps': <ParamEnum.ePeakCurrentLimitAmps: 362>, 'eCurrLimit_Amps': <ParamEnum.eContinuousCurrentLimitAmps: 360>, 'eCurrThres_Amps': <ParamEnum.ePeakCurrentLimitAmps: 362>, 'eCurrEnable': <ParamEnum.eCurrEnable: 363>, 'eCurrThres_Ms': <ParamEnum.eCurrThres_Ms: 364>, 'eClosedLoopIAccum': <ParamEnum.eClosedLoopIAccum: 370>, 'eCustomParam': <ParamEnum.eCustomParam: 380>, 'eStickyFaults': <ParamEnum.eStickyFaults: 390>, 'eAnalogPosition': <ParamEnum.eAnalogPosition: 400>, 'eQuadraturePosition': <ParamEnum.eQuadraturePosition: 401>, 'ePulseWidthPosition': <ParamEnum.ePulseWidthPosition: 402>, 'eIntegratedSensor': <ParamEnum.eIntegratedSensor: 403>, 'eMotMag_Accel': <ParamEnum.eMotMag_Accel: 410>, 'eMotMag_VelCruise': <ParamEnum.eMotMag_VelCruise: 411>, 'eMotMag_SCurveLevel': <ParamEnum.eMotMag_SCurveLevel: 412>, 'eLimitSwitchSource': <ParamEnum.eLimitSwitchSource: 421>, 'eLimitSwitchNormClosedAndDis': <ParamEnum.eLimitSwitchNormClosedAndDis: 422>, 'eLimitSwitchDisableNeutralOnLOS': <ParamEnum.eLimitSwitchDisableNeutralOnLOS: 423>, 'eLimitSwitchRemoteDevID': <ParamEnum.eLimitSwitchRemoteDevID: 424>, 'eSoftLimitDisableNeutralOnLOS': <ParamEnum.eSoftLimitDisableNeutralOnLOS: 425>, 'ePulseWidthPeriod_EdgesPerRot': <ParamEnum.ePulseWidthPeriod_EdgesPerRot: 430>, 'ePulseWidthPeriod_FilterWindowSz': <ParamEnum.ePulseWidthPeriod_FilterWindowSz: 431>, 'eYawOffset': <ParamEnum.eYawOffset: 160>, 'eCompassOffset': <ParamEnum.eCompassOffset: 161>, 'eBetaGain': <ParamEnum.eBetaGain: 162>, 'eEnableCompassFusion': <ParamEnum.eEnableCompassFusion: 163>, 'eGyroNoMotionCal': <ParamEnum.eGyroNoMotionCal: 164>, 'eEnterCalibration': <ParamEnum.eEnterCalibration: 165>, 'eFusedHeadingOffset': <ParamEnum.eFusedHeadingOffset: 166>, 'eStatusFrameRate': <ParamEnum.eStatusFrameRate: 169>, 'eAccumZ': <ParamEnum.eAccumZ: 170>, 'eTempCompDisable': <ParamEnum.eTempCompDisable: 171>, 'eMotionMeas_tap_threshX': <ParamEnum.eMotionMeas_tap_threshX: 172>, 'eMotionMeas_tap_threshY': <ParamEnum.eMotionMeas_tap_threshY: 173>, 'eMotionMeas_tap_threshZ': <ParamEnum.eMotionMeas_tap_threshZ: 174>, 'eMotionMeas_tap_count': <ParamEnum.eMotionMeas_tap_count: 175>, 'eMotionMeas_tap_time': <ParamEnum.eMotionMeas_tap_time: 176>, 'eMotionMeas_tap_time_multi': <ParamEnum.eMotionMeas_tap_time_multi: 177>, 'eMotionMeas_shake_reject_thresh': <ParamEnum.eMotionMeas_shake_reject_thresh: 178>, 'eMotionMeas_shake_reject_time': <ParamEnum.eMotionMeas_shake_reject_time: 179>, 'eMotionMeas_shake_reject_timeout': <ParamEnum.eMotionMeas_shake_reject_timeout: 180>, 'eUnitString': <ParamEnum.eUnitString: 442>, 'eFeedbackTimeBase': <ParamEnum.eFeedbackTimeBase: 443>, 'eDefaultConfig': <ParamEnum.eDefaultConfig: 500>, 'eFastWriteCount': <ParamEnum.eFastWriteCount: 501>, 'eWriteCount': <ParamEnum.eWriteCount: 502>, 'eReserved1': <ParamEnum.eReserved1: 555>, 'eMotorCommutation': <ParamEnum.eMotorCommutation: 650>, 'eSensorInitStrategy': <ParamEnum.eSensorInitStrategy: 700>, 'eSensorDirection': <ParamEnum.eSensorDirection: 701>, 'eMagnetOffset': <ParamEnum.eMagnetOffset: 702>, 'eSensorSync': <ParamEnum.eSensorSync: 703>, 'eAbsSensorRange': <ParamEnum.eAbsSensorRange: 704>, 'eChangeCompassUse': <ParamEnum.eChangeCompassUse: 800>, 'eRestartKalman': <ParamEnum.eRestartKalman: 801>, 'eAccNoiseAmplificationGain': <ParamEnum.eAccNoiseAmplificationGain: 802>, 'eMagNoiseAmplificationGain': <ParamEnum.eMagNoiseAmplificationGain: 803>, 'eGyrNoiseAmplificationGain': <ParamEnum.eGyrNoiseAmplificationGain: 804>, 'eMaxAccKg': <ParamEnum.eMaxAccKg: 805>, 'eMaxMagKg': <ParamEnum.eMaxMagKg: 806>, 'eGyroBias': <ParamEnum.eGyroBias: 807>, 'eAccelOffsets': <ParamEnum.eAccelOffsets: 808>, 'eMagCal': <ParamEnum.eMagCal: 809>, 'eMagCalSlot': <ParamEnum.eMagCalSlot: 810>, 'eMagCalRunning': <ParamEnum.eMagCalRunning: 811>, 'eGyrResolution': <ParamEnum.eGyrResolution: 812>, 'eAccelKalmanBiasGain': <ParamEnum.eAccelKalmanBiasGain: 813>, 'eMagKalmanBiasGain': <ParamEnum.eMagKalmanBiasGain: 814>, 'eTempCalRunning': <ParamEnum.eTempCalRunning: 815>, 'eApplyTempCal': <ParamEnum.eApplyTempCal: 816>, 'eClearTempCal': <ParamEnum.eClearTempCal: 817>, 'eDontRunThermComp': <ParamEnum.eDontRunThermComp: 818>, 'eChangeHeatOutput': <ParamEnum.eChangeHeatOutput: 819>, 'eSetNoMotionCalDisable': <ParamEnum.eSetNoMotionCalDisable: 820>, 'eClearMagCal': <ParamEnum.eClearMagCal: 821>, 'eSetGyrSensitivity': <ParamEnum.eSetGyrSensitivity: 822>, 'eSetVsenseScalar': <ParamEnum.eSetVsenseScalar: 823>, 'eConfigMountPoseYaw': <ParamEnum.eConfigMountPoseYaw: 824>, 'eConfigMountPosePitch': <ParamEnum.eConfigMountPosePitch: 825>, 'eConfigMountPoseRoll': <ParamEnum.eConfigMountPoseRoll: 826>, 'eConfigAccelScalar': <ParamEnum.eConfigAccelScalar: 827>, 'eConfigGyroScalarX': <ParamEnum.eConfigGyroScalarX: 828>, 'eConfigGyroScalarY': <ParamEnum.eConfigGyroScalarY: 829>, 'eConfigGyroScalarZ': <ParamEnum.eConfigGyroScalarZ: 830>, 'eCustomParam0': <ParamEnum.eCustomParam0: 831>, 'eCustomParam1': <ParamEnum.eCustomParam1: 832>, 'eLEDStripType': <ParamEnum.eLEDStripType: 900>, 'eLossOfSignalBehavior': <ParamEnum.eLossOfSignalBehavior: 901>, 'eBrightnessCoefficient': <ParamEnum.eBrightnessCoefficient: 902>, 'eStatusLedState': <ParamEnum.eStatusLedState: 903>, 'eVBatOutput': <ParamEnum.eVBatOutput: 904>, 'eV5Enabled': <ParamEnum.eV5Enabled: 905>}
    eAbsSensorRange: ctre._ctre.ParamEnum # value = <ParamEnum.eAbsSensorRange: 704>
    eAccNoiseAmplificationGain: ctre._ctre.ParamEnum # value = <ParamEnum.eAccNoiseAmplificationGain: 802>
    eAccelKalmanBiasGain: ctre._ctre.ParamEnum # value = <ParamEnum.eAccelKalmanBiasGain: 813>
    eAccelOffsets: ctre._ctre.ParamEnum # value = <ParamEnum.eAccelOffsets: 808>
    eAccumZ: ctre._ctre.ParamEnum # value = <ParamEnum.eAccumZ: 170>
    eAnalogPosition: ctre._ctre.ParamEnum # value = <ParamEnum.eAnalogPosition: 400>
    eApplyTempCal: ctre._ctre.ParamEnum # value = <ParamEnum.eApplyTempCal: 816>
    eBatteryVoltageFilterSize: ctre._ctre.ParamEnum # value = <ParamEnum.eBatteryVoltageFilterSize: 351>
    eBetaGain: ctre._ctre.ParamEnum # value = <ParamEnum.eBetaGain: 162>
    eBrightnessCoefficient: ctre._ctre.ParamEnum # value = <ParamEnum.eBrightnessCoefficient: 902>
    eChangeCompassUse: ctre._ctre.ParamEnum # value = <ParamEnum.eChangeCompassUse: 800>
    eChangeHeatOutput: ctre._ctre.ParamEnum # value = <ParamEnum.eChangeHeatOutput: 819>
    eClearMagCal: ctre._ctre.ParamEnum # value = <ParamEnum.eClearMagCal: 821>
    eClearPositionOnLimitF: ctre._ctre.ParamEnum # value = <ParamEnum.eClearPositionOnLimitF: 320>
    eClearPositionOnLimitR: ctre._ctre.ParamEnum # value = <ParamEnum.eClearPositionOnLimitR: 321>
    eClearPositionOnQuadIdx: ctre._ctre.ParamEnum # value = <ParamEnum.eClearPositionOnQuadIdx: 322>
    eClearTempCal: ctre._ctre.ParamEnum # value = <ParamEnum.eClearTempCal: 817>
    eClosedLoopIAccum: ctre._ctre.ParamEnum # value = <ParamEnum.eClosedLoopIAccum: 370>
    eClosedloopRamp: ctre._ctre.ParamEnum # value = <ParamEnum.eClosedloopRamp: 302>
    eCompassOffset: ctre._ctre.ParamEnum # value = <ParamEnum.eCompassOffset: 161>
    eConfigAccelScalar: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigAccelScalar: 827>
    eConfigGyroScalarX: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigGyroScalarX: 828>
    eConfigGyroScalarY: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigGyroScalarY: 829>
    eConfigGyroScalarZ: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigGyroScalarZ: 830>
    eConfigMountPosePitch: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigMountPosePitch: 825>
    eConfigMountPoseRoll: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigMountPoseRoll: 826>
    eConfigMountPoseYaw: ctre._ctre.ParamEnum # value = <ParamEnum.eConfigMountPoseYaw: 824>
    eContinuousCurrentLimitAmps: ctre._ctre.ParamEnum # value = <ParamEnum.eContinuousCurrentLimitAmps: 360>
    eCurrEnable: ctre._ctre.ParamEnum # value = <ParamEnum.eCurrEnable: 363>
    eCurrLimit_Amps: ctre._ctre.ParamEnum # value = <ParamEnum.eContinuousCurrentLimitAmps: 360>
    eCurrThres_Amps: ctre._ctre.ParamEnum # value = <ParamEnum.ePeakCurrentLimitAmps: 362>
    eCurrThres_Ms: ctre._ctre.ParamEnum # value = <ParamEnum.eCurrThres_Ms: 364>
    eCustomParam: ctre._ctre.ParamEnum # value = <ParamEnum.eCustomParam: 380>
    eCustomParam0: ctre._ctre.ParamEnum # value = <ParamEnum.eCustomParam0: 831>
    eCustomParam1: ctre._ctre.ParamEnum # value = <ParamEnum.eCustomParam1: 832>
    eDefaultConfig: ctre._ctre.ParamEnum # value = <ParamEnum.eDefaultConfig: 500>
    eDontRunThermComp: ctre._ctre.ParamEnum # value = <ParamEnum.eDontRunThermComp: 818>
    eEnableCompassFusion: ctre._ctre.ParamEnum # value = <ParamEnum.eEnableCompassFusion: 163>
    eEnterCalibration: ctre._ctre.ParamEnum # value = <ParamEnum.eEnterCalibration: 165>
    eFastWriteCount: ctre._ctre.ParamEnum # value = <ParamEnum.eFastWriteCount: 501>
    eFeedbackNotContinuous: ctre._ctre.ParamEnum # value = <ParamEnum.eFeedbackNotContinuous: 332>
    eFeedbackSensorType: ctre._ctre.ParamEnum # value = <ParamEnum.eFeedbackSensorType: 330>
    eFeedbackTimeBase: ctre._ctre.ParamEnum # value = <ParamEnum.eFeedbackTimeBase: 443>
    eForwardSoftLimitEnable: ctre._ctre.ParamEnum # value = <ParamEnum.eForwardSoftLimitEnable: 342>
    eForwardSoftLimitThreshold: ctre._ctre.ParamEnum # value = <ParamEnum.eForwardSoftLimitThreshold: 340>
    eFusedHeadingOffset: ctre._ctre.ParamEnum # value = <ParamEnum.eFusedHeadingOffset: 166>
    eGyrNoiseAmplificationGain: ctre._ctre.ParamEnum # value = <ParamEnum.eGyrNoiseAmplificationGain: 804>
    eGyrResolution: ctre._ctre.ParamEnum # value = <ParamEnum.eGyrResolution: 812>
    eGyroBias: ctre._ctre.ParamEnum # value = <ParamEnum.eGyroBias: 807>
    eGyroNoMotionCal: ctre._ctre.ParamEnum # value = <ParamEnum.eGyroNoMotionCal: 164>
    eIntegratedSensor: ctre._ctre.ParamEnum # value = <ParamEnum.eIntegratedSensor: 403>
    eLEDStripType: ctre._ctre.ParamEnum # value = <ParamEnum.eLEDStripType: 900>
    eLimitSwitchDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = <ParamEnum.eLimitSwitchDisableNeutralOnLOS: 423>
    eLimitSwitchNormClosedAndDis: ctre._ctre.ParamEnum # value = <ParamEnum.eLimitSwitchNormClosedAndDis: 422>
    eLimitSwitchRemoteDevID: ctre._ctre.ParamEnum # value = <ParamEnum.eLimitSwitchRemoteDevID: 424>
    eLimitSwitchSource: ctre._ctre.ParamEnum # value = <ParamEnum.eLimitSwitchSource: 421>
    eLossOfSignalBehavior: ctre._ctre.ParamEnum # value = <ParamEnum.eLossOfSignalBehavior: 901>
    eMagCal: ctre._ctre.ParamEnum # value = <ParamEnum.eMagCal: 809>
    eMagCalRunning: ctre._ctre.ParamEnum # value = <ParamEnum.eMagCalRunning: 811>
    eMagCalSlot: ctre._ctre.ParamEnum # value = <ParamEnum.eMagCalSlot: 810>
    eMagKalmanBiasGain: ctre._ctre.ParamEnum # value = <ParamEnum.eMagKalmanBiasGain: 814>
    eMagNoiseAmplificationGain: ctre._ctre.ParamEnum # value = <ParamEnum.eMagNoiseAmplificationGain: 803>
    eMagnetOffset: ctre._ctre.ParamEnum # value = <ParamEnum.eMagnetOffset: 702>
    eMaxAccKg: ctre._ctre.ParamEnum # value = <ParamEnum.eMaxAccKg: 805>
    eMaxMagKg: ctre._ctre.ParamEnum # value = <ParamEnum.eMaxMagKg: 806>
    eMotMag_Accel: ctre._ctre.ParamEnum # value = <ParamEnum.eMotMag_Accel: 410>
    eMotMag_SCurveLevel: ctre._ctre.ParamEnum # value = <ParamEnum.eMotMag_SCurveLevel: 412>
    eMotMag_VelCruise: ctre._ctre.ParamEnum # value = <ParamEnum.eMotMag_VelCruise: 411>
    eMotionMeas_shake_reject_thresh: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_shake_reject_thresh: 178>
    eMotionMeas_shake_reject_time: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_shake_reject_time: 179>
    eMotionMeas_shake_reject_timeout: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_shake_reject_timeout: 180>
    eMotionMeas_tap_count: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_count: 175>
    eMotionMeas_tap_threshX: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_threshX: 172>
    eMotionMeas_tap_threshY: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_threshY: 173>
    eMotionMeas_tap_threshZ: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_threshZ: 174>
    eMotionMeas_tap_time: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_time: 176>
    eMotionMeas_tap_time_multi: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionMeas_tap_time_multi: 177>
    eMotionProfileHasUnderrunErr: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionProfileHasUnderrunErr: 119>
    eMotionProfileTrajectoryInterpolDis: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionProfileTrajectoryInterpolDis: 121>
    eMotionProfileTrajectoryPointDurationMs: ctre._ctre.ParamEnum # value = <ParamEnum.eMotionProfileTrajectoryPointDurationMs: 120>
    eMotorCommutation: ctre._ctre.ParamEnum # value = <ParamEnum.eMotorCommutation: 650>
    eNeutralDeadband: ctre._ctre.ParamEnum # value = <ParamEnum.eNeutralDeadband: 303>
    eNominalBatteryVoltage: ctre._ctre.ParamEnum # value = <ParamEnum.eNominalBatteryVoltage: 350>
    eNominalNegOutput: ctre._ctre.ParamEnum # value = <ParamEnum.eNominalNegOutput: 308>
    eNominalPosOutput: ctre._ctre.ParamEnum # value = <ParamEnum.eNominalPosOutput: 306>
    eOnBoot_BrakeMode: ctre._ctre.ParamEnum # value = <ParamEnum.eOnBoot_BrakeMode: 31>
    eOpenloopRamp: ctre._ctre.ParamEnum # value = <ParamEnum.eOpenloopRamp: 301>
    ePIDLoopPeriod: ctre._ctre.ParamEnum # value = <ParamEnum.ePIDLoopPeriod: 338>
    ePIDLoopPolarity: ctre._ctre.ParamEnum # value = <ParamEnum.ePIDLoopPolarity: 337>
    ePeakCurrentLimitAmps: ctre._ctre.ParamEnum # value = <ParamEnum.ePeakCurrentLimitAmps: 362>
    ePeakCurrentLimitMs: ctre._ctre.ParamEnum # value = <ParamEnum.ePeakCurrentLimitMs: 361>
    ePeakNegOutput: ctre._ctre.ParamEnum # value = <ParamEnum.ePeakNegOutput: 307>
    ePeakPosOutput: ctre._ctre.ParamEnum # value = <ParamEnum.ePeakPosOutput: 305>
    eProfileParamSlot_AllowableErr: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_AllowableErr: 315>
    eProfileParamSlot_D: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_D: 312>
    eProfileParamSlot_F: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_F: 313>
    eProfileParamSlot_I: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_I: 311>
    eProfileParamSlot_IZone: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_IZone: 314>
    eProfileParamSlot_MaxIAccum: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_MaxIAccum: 316>
    eProfileParamSlot_P: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_P: 310>
    eProfileParamSlot_PeakOutput: ctre._ctre.ParamEnum # value = <ParamEnum.eProfileParamSlot_PeakOutput: 317>
    ePulseWidthPeriod_EdgesPerRot: ctre._ctre.ParamEnum # value = <ParamEnum.ePulseWidthPeriod_EdgesPerRot: 430>
    ePulseWidthPeriod_FilterWindowSz: ctre._ctre.ParamEnum # value = <ParamEnum.ePulseWidthPeriod_FilterWindowSz: 431>
    ePulseWidthPosition: ctre._ctre.ParamEnum # value = <ParamEnum.ePulseWidthPosition: 402>
    eQuadFilterEn: ctre._ctre.ParamEnum # value = <ParamEnum.eQuadFilterEn: 91>
    eQuadIdxPolarity: ctre._ctre.ParamEnum # value = <ParamEnum.eQuadIdxPolarity: 108>
    eQuadraturePosition: ctre._ctre.ParamEnum # value = <ParamEnum.eQuadraturePosition: 401>
    eRemoteSensorClosedLoopDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = <ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS: 336>
    eRemoteSensorDeviceID: ctre._ctre.ParamEnum # value = <ParamEnum.eRemoteSensorDeviceID: 334>
    eRemoteSensorSource: ctre._ctre.ParamEnum # value = <ParamEnum.eRemoteSensorSource: 333>
    eReserved1: ctre._ctre.ParamEnum # value = <ParamEnum.eReserved1: 555>
    eRestartKalman: ctre._ctre.ParamEnum # value = <ParamEnum.eRestartKalman: 801>
    eReverseSoftLimitEnable: ctre._ctre.ParamEnum # value = <ParamEnum.eReverseSoftLimitEnable: 343>
    eReverseSoftLimitThreshold: ctre._ctre.ParamEnum # value = <ParamEnum.eReverseSoftLimitThreshold: 341>
    eSampleVelocityPeriod: ctre._ctre.ParamEnum # value = <ParamEnum.eSampleVelocityPeriod: 325>
    eSampleVelocityWindow: ctre._ctre.ParamEnum # value = <ParamEnum.eSampleVelocityWindow: 326>
    eSelectedSensorCoefficient: ctre._ctre.ParamEnum # value = <ParamEnum.eSelectedSensorCoefficient: 339>
    eSelectedSensorPosition: ctre._ctre.ParamEnum # value = <ParamEnum.eSelectedSensorPosition: 331>
    eSensorDirection: ctre._ctre.ParamEnum # value = <ParamEnum.eSensorDirection: 701>
    eSensorInitStrategy: ctre._ctre.ParamEnum # value = <ParamEnum.eSensorInitStrategy: 700>
    eSensorSync: ctre._ctre.ParamEnum # value = <ParamEnum.eSensorSync: 703>
    eSensorTerm: ctre._ctre.ParamEnum # value = <ParamEnum.eSensorTerm: 335>
    eSetGyrSensitivity: ctre._ctre.ParamEnum # value = <ParamEnum.eSetGyrSensitivity: 822>
    eSetNoMotionCalDisable: ctre._ctre.ParamEnum # value = <ParamEnum.eSetNoMotionCalDisable: 820>
    eSetVsenseScalar: ctre._ctre.ParamEnum # value = <ParamEnum.eSetVsenseScalar: 823>
    eSoftLimitDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = <ParamEnum.eSoftLimitDisableNeutralOnLOS: 425>
    eStatusFramePeriod: ctre._ctre.ParamEnum # value = <ParamEnum.eStatusFramePeriod: 300>
    eStatusFrameRate: ctre._ctre.ParamEnum # value = <ParamEnum.eStatusFrameRate: 169>
    eStatusLedState: ctre._ctre.ParamEnum # value = <ParamEnum.eStatusLedState: 903>
    eStickyFaults: ctre._ctre.ParamEnum # value = <ParamEnum.eStickyFaults: 390>
    eTempCalRunning: ctre._ctre.ParamEnum # value = <ParamEnum.eTempCalRunning: 815>
    eTempCompDisable: ctre._ctre.ParamEnum # value = <ParamEnum.eTempCompDisable: 171>
    eUnitString: ctre._ctre.ParamEnum # value = <ParamEnum.eUnitString: 442>
    eV5Enabled: ctre._ctre.ParamEnum # value = <ParamEnum.eV5Enabled: 905>
    eVBatOutput: ctre._ctre.ParamEnum # value = <ParamEnum.eVBatOutput: 904>
    eWriteCount: ctre._ctre.ParamEnum # value = <ParamEnum.eWriteCount: 502>
    eYawOffset: ctre._ctre.ParamEnum # value = <ParamEnum.eYawOffset: 160>
    pass
class RemoteFeedbackDevice():
    """
    Choose the remote feedback device for a motor controller.

    Members:

      FactoryDefaultOff : [[deprecated("Use None instead.")]]
    Factory default setting for non-enhanced motor controllers

      SensorSum : Use Sum0 + Sum1

      SensorDifference : Use Diff0 - Diff1

      RemoteSensor0 : Use the sensor configured
    in filter0

      RemoteSensor1 : Use the sensor configured
    in filter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    FactoryDefaultOff: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.FactoryDefaultOff: 0>
    None_: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.None_: 14>
    RemoteSensor0: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.SensorDifference: 10>
    SensorSum: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: ctre._ctre.RemoteFeedbackDevice # value = <RemoteFeedbackDevice.SoftwareEmulatedSensor: 15>
    __members__: dict # value = {'FactoryDefaultOff': <RemoteFeedbackDevice.FactoryDefaultOff: 0>, 'SensorSum': <RemoteFeedbackDevice.SensorSum: 9>, 'SensorDifference': <RemoteFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <RemoteFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <RemoteFeedbackDevice.RemoteSensor1: 12>, 'None_': <RemoteFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <RemoteFeedbackDevice.SoftwareEmulatedSensor: 15>}
    pass
class RemoteLimitSwitchSource():
    """
    Remote Limit switch source enum

    Members:

      FactoryDefaultOff : Don't use limit switch, this is the factory default value

      RemoteTalon : Use Limit switch connected to Talon on CAN

      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN

      RemoteCANifier : User Limit switch connected to CANifier

      Deactivated : Don't use a limit switch
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Deactivated: ctre._ctre.RemoteLimitSwitchSource # value = <RemoteLimitSwitchSource.Deactivated: 3>
    FactoryDefaultOff: ctre._ctre.RemoteLimitSwitchSource # value = <RemoteLimitSwitchSource.FactoryDefaultOff: 0>
    RemoteCANifier: ctre._ctre.RemoteLimitSwitchSource # value = <RemoteLimitSwitchSource.RemoteCANifier: 2>
    RemoteTalon: ctre._ctre.RemoteLimitSwitchSource # value = <RemoteLimitSwitchSource.RemoteTalon: 1>
    RemoteTalonSRX: ctre._ctre.RemoteLimitSwitchSource # value = <RemoteLimitSwitchSource.RemoteTalon: 1>
    __members__: dict # value = {'FactoryDefaultOff': <RemoteLimitSwitchSource.FactoryDefaultOff: 0>, 'RemoteTalon': <RemoteLimitSwitchSource.RemoteTalon: 1>, 'RemoteTalonSRX': <RemoteLimitSwitchSource.RemoteTalon: 1>, 'RemoteCANifier': <RemoteLimitSwitchSource.RemoteCANifier: 2>, 'Deactivated': <RemoteLimitSwitchSource.Deactivated: 3>}
    pass
class RemoteSensorSource():
    """
    Choose the remote sensor source for a motor controller

    Members:

      Off : Don't use a sensor

      TalonSRX_SelectedSensor : Use a sensor connected to
    a TalonSRX and configured on
    the TalonSRX

      Pigeon_Yaw : Use a CAN Pigeon's Yaw value

      Pigeon_Pitch : Use a CAN Pigeon's Pitch value

      Pigeon_Roll : Use a CAN Pigeon's Roll value

      CANifier_Quadrature : Use a quadrature sensor
    connected to a CANifier

      CANifier_PWMInput0 : Use a PWM sensor connected
    to CANifier's PWM0

      CANifier_PWMInput1 : Use a PWM sensor connected
    to CANifier's PWM1

      CANifier_PWMInput2 : Use a PWM sensor connected
    to CANifier's PWM2

      CANifier_PWMInput3 : Use a PWM sensor connected
    to CANifier's PWM3

      GadgeteerPigeon_Yaw : Use the yaw value of a pigeon
    connected to a talon over ribbon cable

      GadgeteerPigeon_Pitch : Use the pitch value of a pigeon
    connected to a talon over ribbon cable

      GadgeteerPigeon_Roll : Use the roll value of a pigeon
    connected to a talon over ribbon cable

      CANCoder : Use CANCoder

      TalonFX_SelectedSensor : Use a sensor connected to
    a TalonFX and configured on
    the TalonFX
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    CANCoder: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANCoder: 13>
    CANifier_PWMInput0: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANifier_PWMInput0: 6>
    CANifier_PWMInput1: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANifier_PWMInput1: 7>
    CANifier_PWMInput2: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANifier_PWMInput2: 8>
    CANifier_PWMInput3: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANifier_PWMInput3: 9>
    CANifier_Quadrature: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.CANifier_Quadrature: 5>
    GadgeteerPigeon_Pitch: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.GadgeteerPigeon_Pitch: 11>
    GadgeteerPigeon_Roll: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.GadgeteerPigeon_Roll: 12>
    GadgeteerPigeon_Yaw: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.GadgeteerPigeon_Yaw: 10>
    Off: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.Off: 0>
    Pigeon_Pitch: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.Pigeon_Pitch: 3>
    Pigeon_Roll: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.Pigeon_Roll: 4>
    Pigeon_Yaw: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.Pigeon_Yaw: 2>
    TalonFX_SelectedSensor: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.TalonSRX_SelectedSensor: 1>
    TalonSRX_SelectedSensor: ctre._ctre.RemoteSensorSource # value = <RemoteSensorSource.TalonSRX_SelectedSensor: 1>
    __members__: dict # value = {'Off': <RemoteSensorSource.Off: 0>, 'TalonSRX_SelectedSensor': <RemoteSensorSource.TalonSRX_SelectedSensor: 1>, 'Pigeon_Yaw': <RemoteSensorSource.Pigeon_Yaw: 2>, 'Pigeon_Pitch': <RemoteSensorSource.Pigeon_Pitch: 3>, 'Pigeon_Roll': <RemoteSensorSource.Pigeon_Roll: 4>, 'CANifier_Quadrature': <RemoteSensorSource.CANifier_Quadrature: 5>, 'CANifier_PWMInput0': <RemoteSensorSource.CANifier_PWMInput0: 6>, 'CANifier_PWMInput1': <RemoteSensorSource.CANifier_PWMInput1: 7>, 'CANifier_PWMInput2': <RemoteSensorSource.CANifier_PWMInput2: 8>, 'CANifier_PWMInput3': <RemoteSensorSource.CANifier_PWMInput3: 9>, 'GadgeteerPigeon_Yaw': <RemoteSensorSource.GadgeteerPigeon_Yaw: 10>, 'GadgeteerPigeon_Pitch': <RemoteSensorSource.GadgeteerPigeon_Pitch: 11>, 'GadgeteerPigeon_Roll': <RemoteSensorSource.GadgeteerPigeon_Roll: 12>, 'CANCoder': <RemoteSensorSource.CANCoder: 13>, 'TalonFX_SelectedSensor': <RemoteSensorSource.TalonSRX_SelectedSensor: 1>}
    pass
class SensorCollection():
    """
    Collection of sensors available to a motor controller.

    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.

    Use the getSensorCollection() routine inside your motor controller to create a sensor collection.
    """
    def __init__(self, motorController: BaseTalon) -> None: 
        """
        Constructor for SensorCollection

        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getAnalogIn(self) -> int: ...
    def getAnalogInRaw(self) -> int: ...
    def getAnalogInVel(self) -> int: ...
    def getPinStateQuadA(self) -> int: ...
    def getPinStateQuadB(self) -> int: ...
    def getPinStateQuadIdx(self) -> int: ...
    def getPulseWidthPosition(self) -> int: ...
    def getPulseWidthRiseToFallUs(self) -> int: ...
    def getPulseWidthRiseToRiseUs(self) -> int: ...
    def getPulseWidthVelocity(self) -> int: ...
    def getQuadraturePosition(self) -> int: ...
    def getQuadratureVelocity(self) -> int: ...
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    def setAnalogPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: ...
    def setPulseWidthPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets pulse width position.

        :param newPosition: The position value to apply to the sensor.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: an ErrErrorCode
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: ...
    def syncQuadratureWithPulseWidth(self, bookend0: int, bookend1: int, bCrossZeroOnInterval: bool, offset: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class SensorTerm():
    """
    Choose the sensor term for a motor controller

    Members:

      Sum0 : Choose Sum0 for a term

      Sum1 : Choose Sum1 for a term

      Diff0 : Choose Diff0 for a term

      Diff1 : Choose Diff1 for a term
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Diff0: ctre._ctre.SensorTerm # value = <SensorTerm.Diff0: 2>
    Diff1: ctre._ctre.SensorTerm # value = <SensorTerm.Diff1: 3>
    Sum0: ctre._ctre.SensorTerm # value = <SensorTerm.Sum0: 0>
    Sum1: ctre._ctre.SensorTerm # value = <SensorTerm.Sum1: 1>
    __members__: dict # value = {'Sum0': <SensorTerm.Sum0: 0>, 'Sum1': <SensorTerm.Sum1: 1>, 'Diff0': <SensorTerm.Diff0: 2>, 'Diff1': <SensorTerm.Diff1: 3>}
    pass
class SetValueMotionProfile():
    """
    Members:

      Disable

      Enable

      Hold
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Disable: ctre._ctre.SetValueMotionProfile # value = <SetValueMotionProfile.Disable: 0>
    Enable: ctre._ctre.SetValueMotionProfile # value = <SetValueMotionProfile.Enable: 1>
    Hold: ctre._ctre.SetValueMotionProfile # value = <SetValueMotionProfile.Hold: 2>
    __members__: dict # value = {'Disable': <SetValueMotionProfile.Disable: 0>, 'Enable': <SetValueMotionProfile.Enable: 1>, 'Hold': <SetValueMotionProfile.Hold: 2>}
    pass
class SlotConfigUtil():
    """
    Util Class to help with slot configs
    """
    @staticmethod
    def KDDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KFDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KIDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KPDifferent(settings: SlotConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None: ...
    @staticmethod
    def allowableClosedloopErrorDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def closedLoopPeakOutputDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def closedLoopPeriodDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def integralZoneDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def maxIntegralAccumulatorDifferent(settings: SlotConfiguration) -> bool: ...
    pass
class SlotConfiguration():
    """
    Configurables available to a slot
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @property
    def allowableClosedloopError(self) -> float:
        """
        Allowable closed loop error to neutral (in native units)

        :type: float
        """
    @allowableClosedloopError.setter
    def allowableClosedloopError(self, arg0: float) -> None:
        """
        Allowable closed loop error to neutral (in native units)
        """
    @property
    def closedLoopPeakOutput(self) -> float:
        """
        Peak output from closed loop [0,1]

        :type: float
        """
    @closedLoopPeakOutput.setter
    def closedLoopPeakOutput(self, arg0: float) -> None:
        """
        Peak output from closed loop [0,1]
        """
    @property
    def closedLoopPeriod(self) -> int:
        """
        Desired period of closed loop [1,64]ms

        :type: int
        """
    @closedLoopPeriod.setter
    def closedLoopPeriod(self, arg0: int) -> None:
        """
        Desired period of closed loop [1,64]ms
        """
    @property
    def integralZone(self) -> float:
        """
        Integral zone (in native units)

        If the (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :type: float
        """
    @integralZone.setter
    def integralZone(self, arg0: float) -> None:
        """
        Integral zone (in native units)

        If the (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.
        """
    @property
    def kD(self) -> float:
        """
        D Gain

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :type: float
        """
    @kD.setter
    def kD(self, arg0: float) -> None:
        """
        D Gain

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
        """
    @property
    def kF(self) -> float:
        """
        F Gain

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :type: float
        """
    @kF.setter
    def kF(self, arg0: float) -> None:
        """
        F Gain

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
        """
    @property
    def kI(self) -> float:
        """
        I Gain

        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :type: float
        """
    @kI.setter
    def kI(self, arg0: float) -> None:
        """
        I Gain

        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
        """
    @property
    def kP(self) -> float:
        """
        P Gain

        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :type: float
        """
    @kP.setter
    def kP(self, arg0: float) -> None:
        """
        P Gain

        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
        """
    @property
    def maxIntegralAccumulator(self) -> float:
        """
        Max integral accumulator (in native units)

        :type: float
        """
    @maxIntegralAccumulator.setter
    def maxIntegralAccumulator(self, arg0: float) -> None:
        """
        Max integral accumulator (in native units)
        """
    pass
class StatorCurrentLimitConfiguration():
    """
    Describes the desired stator current limiting behavior.
    """
    def __eq__(self, rhs: StatorCurrentLimitConfiguration) -> bool: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Default c'tor.  Because currentLimit is zero, limiting id disabled.
        """
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    def toArray(self) -> typing.List[float]: ...
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.

        :type: float
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.

        :type: bool
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        """
        True/False to enable/disable limit feature.
        """
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.

        :type: float
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.

        :type: float
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    __hash__ = None
    pass
class StatusFrame():
    """
    The different status frames available to motor controllers

    Members:

      Status_1_General_ : General Status

      Status_2_Feedback0_ : Main controller feedback

      Status_4_AinTempVbat_ : Analog sensor, motor controller
    temperature, and voltage at input leads

      Status_6_Misc_ : Miscellaneous signals

      Status_7_CommStatus_ : Communication status to controller

      Status_9_MotProfBuffer_ : Motion profile buffer status

      Status_10_MotionMagic_ : Old name for Status 10.
    Use @see #Status_10_Targets instead.

      Status_10_Targets_ : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic

      Status_12_Feedback1_ : Secondary controller feedback

      Status_13_Base_PIDF0_ : Base PID

      Status_14_Turn_PIDF1_ : Auxiliary PID

      Status_15_FirmwareApiStatus_ : Firmware & API status information

      Status_15_FirmareApiStatus_ : Firmware & API status information
    [[deprecated("Use Status_15_FirmwareApiStatus\_ instead.")]]

      Status_17_Targets1_ : MotionProfile Targets for Auxiliary PID1.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Status_10_MotionMagic_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_10_MotionMagic_: 5696>
    Status_10_Targets_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_10_MotionMagic_: 5696>
    Status_12_Feedback1_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_12_Feedback1_: 5824>
    Status_13_Base_PIDF0_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_13_Base_PIDF0_: 5888>
    Status_14_Turn_PIDF1_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_14_Turn_PIDF1_: 5952>
    Status_15_FirmareApiStatus_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_15_FirmwareApiStatus_: 6016>
    Status_15_FirmwareApiStatus_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_15_FirmwareApiStatus_: 6016>
    Status_17_Targets1_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_17_Targets1_: 7168>
    Status_1_General_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_1_General_: 5120>
    Status_2_Feedback0_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_2_Feedback0_: 5184>
    Status_4_AinTempVbat_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_4_AinTempVbat_: 5312>
    Status_6_Misc_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_6_Misc_: 5440>
    Status_7_CommStatus_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_7_CommStatus_: 5504>
    Status_9_MotProfBuffer_: ctre._ctre.StatusFrame # value = <StatusFrame.Status_9_MotProfBuffer_: 5632>
    __members__: dict # value = {'Status_1_General_': <StatusFrame.Status_1_General_: 5120>, 'Status_2_Feedback0_': <StatusFrame.Status_2_Feedback0_: 5184>, 'Status_4_AinTempVbat_': <StatusFrame.Status_4_AinTempVbat_: 5312>, 'Status_6_Misc_': <StatusFrame.Status_6_Misc_: 5440>, 'Status_7_CommStatus_': <StatusFrame.Status_7_CommStatus_: 5504>, 'Status_9_MotProfBuffer_': <StatusFrame.Status_9_MotProfBuffer_: 5632>, 'Status_10_MotionMagic_': <StatusFrame.Status_10_MotionMagic_: 5696>, 'Status_10_Targets_': <StatusFrame.Status_10_MotionMagic_: 5696>, 'Status_12_Feedback1_': <StatusFrame.Status_12_Feedback1_: 5824>, 'Status_13_Base_PIDF0_': <StatusFrame.Status_13_Base_PIDF0_: 5888>, 'Status_14_Turn_PIDF1_': <StatusFrame.Status_14_Turn_PIDF1_: 5952>, 'Status_15_FirmwareApiStatus_': <StatusFrame.Status_15_FirmwareApiStatus_: 6016>, 'Status_15_FirmareApiStatus_': <StatusFrame.Status_15_FirmwareApiStatus_: 6016>, 'Status_17_Targets1_': <StatusFrame.Status_17_Targets1_: 7168>}
    pass
class StatusFrameEnhanced():
    """
    The different status frames available to enhanced motor controllers

    Members:

      Status_1_General : General Status

      Status_2_Feedback0 : Feedback for selected sensor on primary PID[0].

      Status_4_AinTempVbat : Analog sensor, motor controller
    temperature, and voltage at input leads

      Status_6_Misc : Miscellaneous signals

      Status_7_CommStatus : Communication status

      Status_9_MotProfBuffer : Motion profile buffer status

      Status_10_MotionMagic : Old name for Status 10.
    Use @see #Status_10_Targets instead.

      Status_10_Targets : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic

      Status_12_Feedback1 : Feedback for selected sensor on aux PID[1].

      Status_13_Base_PIDF0 : Primary PID

      Status_14_Turn_PIDF1 : Auxiliary PID

      Status_15_FirmwareApiStatus : Firmware & API status information

      Status_15_FirmareApiStatus : Firmware & API status information
    [[deprecated("Use Status_15_FirmwareApiStatus instead.")]]

      Status_17_Targets1 : MotionProfile Targets for Auxiliary PID1.

      Status_3_Quadrature : Quadrature sensor

      Status_8_PulseWidth : Pulse width sensor

      Status_11_UartGadgeteer : Gadgeteer status

      Status_Brushless_Current : Brushless Current Status.
    Includes Stator and Supply Current for Talon FX.

      Status_21_FeedbackIntegrated : FX Integrated sensor
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Status_10_MotionMagic: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_10_MotionMagic: 5696>
    Status_10_Targets: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_10_MotionMagic: 5696>
    Status_11_UartGadgeteer: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_11_UartGadgeteer: 5760>
    Status_12_Feedback1: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_12_Feedback1: 5824>
    Status_13_Base_PIDF0: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_13_Base_PIDF0: 5888>
    Status_14_Turn_PIDF1: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_14_Turn_PIDF1: 5952>
    Status_15_FirmareApiStatus: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>
    Status_15_FirmwareApiStatus: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>
    Status_17_Targets1: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_17_Targets1: 7168>
    Status_1_General: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_1_General: 5120>
    Status_21_FeedbackIntegrated: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_21_FeedbackIntegrated: 9472>
    Status_2_Feedback0: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_2_Feedback0: 5184>
    Status_3_Quadrature: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_3_Quadrature: 5248>
    Status_4_AinTempVbat: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_4_AinTempVbat: 5312>
    Status_6_Misc: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_6_Misc: 5440>
    Status_7_CommStatus: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_7_CommStatus: 5504>
    Status_8_PulseWidth: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_8_PulseWidth: 5568>
    Status_9_MotProfBuffer: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_9_MotProfBuffer: 5632>
    Status_Brushless_Current: ctre._ctre.StatusFrameEnhanced # value = <StatusFrameEnhanced.Status_Brushless_Current: 4672>
    __members__: dict # value = {'Status_1_General': <StatusFrameEnhanced.Status_1_General: 5120>, 'Status_2_Feedback0': <StatusFrameEnhanced.Status_2_Feedback0: 5184>, 'Status_4_AinTempVbat': <StatusFrameEnhanced.Status_4_AinTempVbat: 5312>, 'Status_6_Misc': <StatusFrameEnhanced.Status_6_Misc: 5440>, 'Status_7_CommStatus': <StatusFrameEnhanced.Status_7_CommStatus: 5504>, 'Status_9_MotProfBuffer': <StatusFrameEnhanced.Status_9_MotProfBuffer: 5632>, 'Status_10_MotionMagic': <StatusFrameEnhanced.Status_10_MotionMagic: 5696>, 'Status_10_Targets': <StatusFrameEnhanced.Status_10_MotionMagic: 5696>, 'Status_12_Feedback1': <StatusFrameEnhanced.Status_12_Feedback1: 5824>, 'Status_13_Base_PIDF0': <StatusFrameEnhanced.Status_13_Base_PIDF0: 5888>, 'Status_14_Turn_PIDF1': <StatusFrameEnhanced.Status_14_Turn_PIDF1: 5952>, 'Status_15_FirmwareApiStatus': <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>, 'Status_15_FirmareApiStatus': <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>, 'Status_17_Targets1': <StatusFrameEnhanced.Status_17_Targets1: 7168>, 'Status_3_Quadrature': <StatusFrameEnhanced.Status_3_Quadrature: 5248>, 'Status_8_PulseWidth': <StatusFrameEnhanced.Status_8_PulseWidth: 5568>, 'Status_11_UartGadgeteer': <StatusFrameEnhanced.Status_11_UartGadgeteer: 5760>, 'Status_Brushless_Current': <StatusFrameEnhanced.Status_Brushless_Current: 4672>, 'Status_21_FeedbackIntegrated': <StatusFrameEnhanced.Status_21_FeedbackIntegrated: 9472>}
    pass
class StatusFrameRoutines():
    """
    Class to allow conversion from StatusFrame to EnhancedStatusFrame
    """
    def promote(self, statusFrame: StatusFrame) -> StatusFrameEnhanced: 
        """
        Converts a status frame to an enhanced status frame

        :param statusFrame: frame to convert

        :returns: enhanced status frame version of statusFrame
        """
    pass
class StickyFaults():
    """
    All the sticky faults available to motor controllers
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    @property
    def APIError(self) -> bool:
        """
        Device detects an API error

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        Device detects an API error
        """
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see #ResetDuringEn

        :type: bool
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        """
        Not used, @see #ResetDuringEn
        """
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus

        :type: bool
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        """
        Remote Sensor is no longer detected on bus
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase

        :type: bool
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        """
        Device detects its sensor is out of phase
        """
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed

        :type: bool
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        """
        Device's sensor overflowed
        """
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Motor Controller is under 6.5V
        """
    pass
class SupplyCurrentLimitConfiguration():
    """
    Describes the desired stator current limiting behavior.
    """
    def __eq__(self, rhs: SupplyCurrentLimitConfiguration) -> bool: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Default c'tor.  Because currentLimit is zero, limiting is disabled.
        """
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    def toArray(self) -> typing.List[float]: ...
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.

        :type: float
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.

        :type: bool
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        """
        True/False to enable/disable limit feature.
        """
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.

        :type: float
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.

        :type: float
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    __hash__ = None
    pass
class TalonFX(BaseTalon, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon FX Motor Controller when used on CAN Bus.

    ::

      {@code
      // Example usage of a TalonFX motor controller
      TalonFX motor{0}; // creates a new TalonFX with ID 0
      
      TalonFXConfiguration config;
      config.supplyCurrLimit.enable = true;
      config.supplyCurrLimit.triggerThresholdCurrent = 40; // the peak supply current, in amps
      config.supplyCurrLimit.triggerThresholdTime = 1.5; // the time at the peak supply current before the limit triggers, in sec
      config.supplyCurrLimit.currentLimit = 30; // the current to maintain if the peak supply limit is triggered
      motor.ConfigAllSettings(config); // apply the config settings; this selects the quadrature encoder
      
      motor.Set(TalonFXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetSelectedSensorPosition() << std::endl; // prints the position of the selected sensor
      std::cout << motor.GetSelectedSensorVelocity() << std::endl; // prints the velocity recorded by the selected sensor
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetStatorCurrent() << std::endl; // prints the output current of the motor
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      
      motor.SetStatusFramePeriod(StatusFrameEnhanced::Status_2_Feedback0, 10); // changes the period of the Status 2 frame (GetSelectedSensor*()) to 10ms
      }

    .. seealso::
       :class:`WPI_TalonFX`
    """
    def __init__(self, deviceNumber: int, canbus: str = '') -> None: 
        """
        Constructor for a Talon

        :param deviceNumber: CAN Device ID of TalonFX
        :param canbus:       Name of the CANbus; can be a SocketCAN interface (on Linux),
                             or a CANivore device name or serial number
        """
    def configAllSettings(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode: 
        """
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out.

        :returns: The motor commutation type.
        """
    def configGetStatorCurrentLimit(self, currLimitConfigsToFill: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Gets the stator (output) current limit configuration.

        :param currLimitConfigsToFill: Configuration object to fill with read values.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetSupplyCurrentLimit(self, currLimitConfigsToFill: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Gets the supply current limit configuration.

        :param currLimitConfigsToFill: Configuration object to fill with read values.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorAbsoluteRange(self, absoluteSensorRange: sensors.AbsoluteSensorRange, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the signage and range of the "Absolute Position" signal.
        Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
        Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...

        :param absoluteSensorRange: Desired Sign/Range for the absolute position register.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorInitializationStrategy(self, initializationStrategy: sensors.SensorInitializationStrategy, timeoutMs: int = 0) -> ErrorCode: 
        """
        Pick the strategy on how to initialize the integrated sensor absolute position register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
        Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the product is reset.

        :param initializationStrategy: The sensor initialization strategy to use.  This will impact the behavior the next time product boots up.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorOffset(self, offsetDegrees: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :param offsetDegrees: Offset in degrees (unit string and coefficient DO NOT apply for this config).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the motor commutation type.

        :param motorCommutation: Motor Commutation Type.
        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for config
                                 success and report an error if it times out. If zero, no
                                 blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Talon FX Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonFXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configStatorCurrentLimit(self, currLimitConfigs: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the stator (output) current limit.

        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the supply-side current limit.

        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets all PID persistant settings.

        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getAllConfigs(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> TalonFXSensorCollection: 
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    def getSimCollection(self) -> TalonFXSimCollection: 
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        *       Standard Driving Example:
        *       _talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *       _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.

        Arcade Drive Example:
        *               _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None: ...
    pass
class TalonFXConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def absoluteSensorRangeDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def initializationStrategyDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def integratedSensorOffsetDegreesDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def motorCommutationDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def statorCurrentDurationDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def supplyCurrentLimitDifferent(settings: TalonFXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class TalonFXConfiguration(BaseTalonConfiguration, BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to TalonFX
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @property
    def absoluteSensorRange(self) -> sensors.AbsoluteSensorRange:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.

        :type: sensors.AbsoluteSensorRange
        """
    @absoluteSensorRange.setter
    def absoluteSensorRange(self, arg0: sensors.AbsoluteSensorRange) -> None:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.
        """
    @property
    def initializationStrategy(self) -> sensors.SensorInitializationStrategy:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time device boots up.

        Pick the strategy on how to initialize the "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the device is reset.

        :type: sensors.SensorInitializationStrategy
        """
    @initializationStrategy.setter
    def initializationStrategy(self, arg0: sensors.SensorInitializationStrategy) -> None:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time device boots up.

        Pick the strategy on how to initialize the "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the device is reset.
        """
    @property
    def integratedSensorOffsetDegrees(self) -> float:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :type: float
        """
    @integratedSensorOffsetDegrees.setter
    def integratedSensorOffsetDegrees(self, arg0: float) -> None:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.
        """
    @property
    def motorCommutation(self) -> MotorCommutation:
        """
        Choose the type of motor commutation.

        :type: MotorCommutation
        """
    @motorCommutation.setter
    def motorCommutation(self, arg0: MotorCommutation) -> None:
        """
        Choose the type of motor commutation.
        """
    @property
    def statorCurrLimit(self) -> StatorCurrentLimitConfiguration:
        """
        Stator-side current limiting.  This is typically used to limit acceleration/torque and heat generation.

        :type: StatorCurrentLimitConfiguration
        """
    @statorCurrLimit.setter
    def statorCurrLimit(self, arg0: StatorCurrentLimitConfiguration) -> None:
        """
        Stator-side current limiting.  This is typically used to limit acceleration/torque and heat generation.
        """
    @property
    def supplyCurrLimit(self) -> SupplyCurrentLimitConfiguration:
        """
        Supply-side current limiting.  This is typically used to prevent breakers from tripping.

        :type: SupplyCurrentLimitConfiguration
        """
    @supplyCurrLimit.setter
    def supplyCurrLimit(self, arg0: SupplyCurrentLimitConfiguration) -> None:
        """
        Supply-side current limiting.  This is typically used to prevent breakers from tripping.
        """
    pass
class TalonFXControlMode():
    """
    Choose the control mode for a TalonFX / Falcon 500.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.

      Disabled : Disable Motor Controller
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Current: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.Current: 3>
    Disabled: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.Disabled: 15>
    Follower: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.Follower: 5>
    MotionMagic: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.MotionMagic: 7>
    MotionProfile: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.MotionProfile: 6>
    MotionProfileArc: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.MotionProfileArc: 10>
    MusicTone: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.MusicTone: 13>
    PercentOutput: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.PercentOutput: 0>
    Position: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.Position: 1>
    Velocity: ctre._ctre.TalonFXControlMode # value = <TalonFXControlMode.Velocity: 2>
    __members__: dict # value = {'PercentOutput': <TalonFXControlMode.PercentOutput: 0>, 'Position': <TalonFXControlMode.Position: 1>, 'Velocity': <TalonFXControlMode.Velocity: 2>, 'Current': <TalonFXControlMode.Current: 3>, 'Follower': <TalonFXControlMode.Follower: 5>, 'MotionProfile': <TalonFXControlMode.MotionProfile: 6>, 'MotionMagic': <TalonFXControlMode.MotionMagic: 7>, 'MotionProfileArc': <TalonFXControlMode.MotionProfileArc: 10>, 'MusicTone': <TalonFXControlMode.MusicTone: 13>, 'Disabled': <TalonFXControlMode.Disabled: 15>}
    pass
class TalonFXFeedbackDevice():
    """
    Choose the feedback device for a Talon FX/Falcon 500.

    Members:

      IntegratedSensor : TalonFX supports an integrated sensor.

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    IntegratedSensor: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.IntegratedSensor: 1>
    None_: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.None_: 14>
    RemoteSensor0: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.SensorDifference: 10>
    SensorSum: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: ctre._ctre.TalonFXFeedbackDevice # value = <TalonFXFeedbackDevice.SoftwareEmulatedSensor: 15>
    __members__: dict # value = {'IntegratedSensor': <TalonFXFeedbackDevice.IntegratedSensor: 1>, 'SensorSum': <TalonFXFeedbackDevice.SensorSum: 9>, 'SensorDifference': <TalonFXFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <TalonFXFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <TalonFXFeedbackDevice.RemoteSensor1: 12>, 'None_': <TalonFXFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <TalonFXFeedbackDevice.SoftwareEmulatedSensor: 15>}
    pass
class TalonFXInvertType():
    """
    Choose the invert type for a Talon FX based integrated motor controller.
    CCW is the equivalent of SetInverted(false), CW is the equivalent of SetInverted(true).
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.

    Members:

      CounterClockwise : Same as SetInverted(false)

      Clockwise : Same as SetInverted(true)

      FollowMaster : Follow the invert of the master this MC is following.

      OpposeMaster : Opposite of the invert of the master this MC is following.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Clockwise: ctre._ctre.TalonFXInvertType # value = <TalonFXInvertType.Clockwise: 1>
    CounterClockwise: ctre._ctre.TalonFXInvertType # value = <TalonFXInvertType.CounterClockwise: 0>
    FollowMaster: ctre._ctre.TalonFXInvertType # value = <TalonFXInvertType.FollowMaster: 2>
    OpposeMaster: ctre._ctre.TalonFXInvertType # value = <TalonFXInvertType.OpposeMaster: 3>
    __members__: dict # value = {'CounterClockwise': <TalonFXInvertType.CounterClockwise: 0>, 'Clockwise': <TalonFXInvertType.Clockwise: 1>, 'FollowMaster': <TalonFXInvertType.FollowMaster: 2>, 'OpposeMaster': <TalonFXInvertType.OpposeMaster: 3>}
    pass
class TalonFXPIDSetConfiguration(BaseTalonPIDSetConfiguration, BasePIDSetConfiguration):
    """
    Configurables available to TalonFX's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    pass
class TalonFXSensorCollection():
    """
    Collection of sensors available to the Talon FX.

    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.

    Use the GetTalonFXSensorCollection() routine inside your motor controller to create a sensor collection.
    """
    def __init__(self, motorController: BaseTalon) -> None: 
        """
        Constructor for TalonFXSensorCollection

        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getIntegratedSensorAbsolutePosition(self) -> float: 
        """
        Get the IntegratedSensor absolute position of the Talon FX, regardless of whether
        it is actually being used for feedback.  This will be within one rotation (2048 units).
        The signage and range will depend on the configuration.
        *       Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.

        This method relies on the Status 21 message, which has a default period of 240ms. For more
        information, see: https://phoenix-documentation.readthedocs.io/en/latest/ch18_CommonAPI.html

        :returns: the IntegratedSensor absolute position.
        """
    def getIntegratedSensorPosition(self) -> float: ...
    def getIntegratedSensorVelocity(self) -> float: 
        """
        Get the IntegratedSensor velocity of the Talon FX, regardless of whether
        it is actually being used for feedback.
        One unit represents one position unit per 100ms (2048 position units per 100ms).
        The signage and range will depend on the configuration.
        *       Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.

        This method relies on the Status 21 message, which has a default period of 240ms. For more
        information, see: https://phoenix-documentation.readthedocs.io/en/latest/ch18_CommonAPI.html

        :returns: the IntegratedSensor velocity.
        """
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    def setIntegratedSensorPosition(self, newPosition: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Set the IntegratedSensor reported position.  Typically this is used to "zero" the
        sensor. This only works with IntegratedSensor.  To set the selected sensor position
        regardless of what type it is, see SetSelectedSensorPosition in the motor controller class.

        :param newPosition: The position value to apply to the sensor.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.

        :returns: error code.
        """
    def setIntegratedSensorPositionToAbsolute(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Set the IntegratedSensor reported position based on the absolute position.
        This can also be done automatically on power boot depending on configuration.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: error code.
        """
    pass
class TalonFXSimCollection():
    """
    Collection of simulation commands available to a TalonFX motor controller.

    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    """
    def __init__(self, motorController: BaseTalon) -> None: 
        """
        Constructor for TalonFXSimCollection

        :param motorController: TalonFX Motor Controller to connect Collection to
        """
    def addIntegratedSensorPosition(self, dPos: int) -> ErrorCode: 
        """
        Adds to the simulated integrated sensor position of the TalonFX.

        :param dPos: the change in position in native units

        :returns: error code
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float: 
        """
        Gets the simulated output voltage across M+ and M- for the motor.

        :returns: applied voltage to the motor in volts
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode: 
        """
        Sets the simulated bus voltage of the TalonFX.

        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.

        :param vbat: the bus voltage in volts

        :returns: error code
        """
    def setIntegratedSensorRawPosition(self, newPos: int) -> ErrorCode: 
        """
        Sets the simulated raw integrated sensor position of the TalonFX.

        The TalonFX integrates this to calculate the true reported integrated sensor
        position.

        When using the WPI Sim GUI, you will notice a readonly 'position' and
        settable 'rawPositionInput'.  The readonly signal is the emulated position
        which will match self-test in Tuner and the hardware API.  Changes to
        'rawPositionInput' will be integrated into the emulated position.  This way
        a simulator can modify the position without overriding your
        hardware API calls for home-ing your sensor.

        Inputs to this function over time should be continuous,
        as user calls of SetSelectedSensorPosition() and SetIntegratedSensorPosition()
        will be accounted for in the calculation.

        :param newPos: the new raw position in native units

        :returns: error code
        """
    def setIntegratedSensorVelocity(self, newVel: int) -> ErrorCode: 
        """
        Sets the simulated integrated sensor velocity of the TalonFX.

        :param newVel: the new velocity in native units per 100ms

        :returns: error code
        """
    def setLimitFwd(self, isClosed: bool) -> ErrorCode: 
        """
        Sets the simulated forward limit switch of the TalonFX.

        :param isClosed: true if the limit switch is closed

        :returns: error code
        """
    def setLimitRev(self, isClosed: bool) -> ErrorCode: 
        """
        Sets the simulated reverse limit switch of the TalonFX.

        :param isClosed: true if the limit switch is closed

        :returns: error code
        """
    def setStatorCurrent(self, currA: float) -> ErrorCode: 
        """
        Sets the simulated stator current of the TalonFX.

        :param currA: the stator current in amps

        :returns: error code
        """
    def setSupplyCurrent(self, currA: float) -> ErrorCode: 
        """
        Sets the simulated supply current of the TalonFX.

        :param currA: the supply current in amps

        :returns: error code
        """
    pass
class TalonSRX(BaseTalon, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.

    ::

      {@code
      // Example usage of a TalonSRX motor controller
      TalonSRX motor{0}; // creates a new TalonSRX with ID 0
      
      TalonSRXConfiguration config;
      config.peakCurrentLimit = 40; // the peak current, in amps
      config.peakCurrentDuration = 1500; // the time at the peak current before the limit triggers, in ms
      config.continuousCurrentLimit = 30; // the current to maintain if the peak limit is triggered
      motor.ConfigAllSettings(config); // apply the config settings; this selects the quadrature encoder
      
      motor.Set(TalonSRXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetSelectedSensorPosition() << std::endl; // prints the position of the selected sensor
      std::cout << motor.GetSelectedSensorVelocity() << std::endl; // prints the velocity recorded by the selected sensor
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetStatorCurrent() << std::endl; // prints the output current of the motor
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      
      motor.SetStatusFramePeriod(StatusFrameEnhanced::Status_2_Feedback0, 10); // changes the period of the Status 2 frame (GetSelectedSensor*()) to 10ms
      }

    .. seealso::
       :class:`WPI_TalonSRX`
    """
    @typing.overload
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a Talon

        :param deviceNumber: CAN Device ID of TalonSRX

        Constructor so non-FRC platforms can specify a CAN 2.0 socketcan bus

        :param deviceNumber: CAN Device ID of TalonSRX
        :param canbus:       String specifying the bus
        """
    @typing.overload
    def __init__(self, deviceNumber: int, canbus: str) -> None: ...
    def configAllSettings(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configContinuousCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the continuous allowable current-draw (when current limit is
        enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param amps:      Amperes to limit.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        """
    def configPeakCurrentDuration(self, milliseconds: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the peak allowable duration (when current limit is enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param milliseconds: How long to allow current-draw past peak limit.
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for config
                             success and report an error if it times out. If zero, no
                             blocking or checking is performed.
        """
    def configPeakCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the peak allowable current (when current limit is enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param amps:      Amperes to limit.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Talon SRX Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int, timeoutMs: int) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonSRXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the supply (input) current limit.

        :param currLimitConfigs: Current limit configuration
        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for
                                 config success and report an error if it times out.
                                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets all PID persistant settings.

        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def enableCurrentLimit(self, enable: bool) -> None: 
        """
        Enable or disable Current Limit.

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        :param enable: Enable state of current limit.
                       @see configPeakCurrentLimit()
                       @see configPeakCurrentDuration()
                       @see configContinuousCurrentLimit()
        """
    def getAllConfigs(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> SensorCollection: 
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    def getSimCollection(self) -> TalonSRXSimCollection: 
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        *       Standard Driving Example:
        *       _talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *       _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.

        Arcade Drive Example:
        *               _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None: ...
    pass
class TalonSRXConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def continuousCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool: ...
    @staticmethod
    def peakCurrentDurationDifferent(settings: TalonSRXConfiguration) -> bool: ...
    @staticmethod
    def peakCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class TalonSRXConfiguration(BaseTalonConfiguration, BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to TalonSRX
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @property
    def continuousCurrentLimit(self) -> int:
        """
        Continuous current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @continuousCurrentLimit.setter
    def continuousCurrentLimit(self, arg0: int) -> None:
        """
        Continuous current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @property
    def peakCurrentDuration(self) -> int:
        """
        Peak Current duration in milliseconds

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @peakCurrentDuration.setter
    def peakCurrentDuration(self, arg0: int) -> None:
        """
        Peak Current duration in milliseconds

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @property
    def peakCurrentLimit(self) -> int:
        """
        Peak current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @peakCurrentLimit.setter
    def peakCurrentLimit(self, arg0: int) -> None:
        """
        Peak current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    pass
class TalonSRXControlMode():
    """
    Choose the control mode for a Talon SRX.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      Disabled : Disable Motor Controller
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Current: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.Current: 3>
    Disabled: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.Disabled: 15>
    Follower: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.Follower: 5>
    MotionMagic: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.MotionMagic: 7>
    MotionProfile: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.MotionProfile: 6>
    MotionProfileArc: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.MotionProfileArc: 10>
    PercentOutput: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.PercentOutput: 0>
    Position: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.Position: 1>
    Velocity: ctre._ctre.TalonSRXControlMode # value = <TalonSRXControlMode.Velocity: 2>
    __members__: dict # value = {'PercentOutput': <TalonSRXControlMode.PercentOutput: 0>, 'Position': <TalonSRXControlMode.Position: 1>, 'Velocity': <TalonSRXControlMode.Velocity: 2>, 'Current': <TalonSRXControlMode.Current: 3>, 'Follower': <TalonSRXControlMode.Follower: 5>, 'MotionProfile': <TalonSRXControlMode.MotionProfile: 6>, 'MotionMagic': <TalonSRXControlMode.MotionMagic: 7>, 'MotionProfileArc': <TalonSRXControlMode.MotionProfileArc: 10>, 'Disabled': <TalonSRXControlMode.Disabled: 15>}
    pass
class TalonSRXFeedbackDevice():
    """
    Choose the feedback device for a Talon SRX

    Members:

      QuadEncoder : Quadrature encoder

      Analog : Analog potentiometer/encoder

      Tachometer : Tachometer

      PulseWidthEncodedPosition : CTRE Mag Encoder in Absolute mode or
    any other device that uses PWM to encode its output

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.

      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.

      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Analog: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.Analog: 2>
    CTRE_MagEncoder_Absolute: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>
    CTRE_MagEncoder_Relative: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.QuadEncoder: 0>
    None_: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.None_: 14>
    PulseWidthEncodedPosition: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>
    QuadEncoder: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.QuadEncoder: 0>
    RemoteSensor0: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.SensorDifference: 10>
    SensorSum: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.SoftwareEmulatedSensor: 15>
    Tachometer: ctre._ctre.TalonSRXFeedbackDevice # value = <TalonSRXFeedbackDevice.Tachometer: 4>
    __members__: dict # value = {'QuadEncoder': <TalonSRXFeedbackDevice.QuadEncoder: 0>, 'Analog': <TalonSRXFeedbackDevice.Analog: 2>, 'Tachometer': <TalonSRXFeedbackDevice.Tachometer: 4>, 'PulseWidthEncodedPosition': <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>, 'SensorSum': <TalonSRXFeedbackDevice.SensorSum: 9>, 'SensorDifference': <TalonSRXFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <TalonSRXFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <TalonSRXFeedbackDevice.RemoteSensor1: 12>, 'None_': <TalonSRXFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <TalonSRXFeedbackDevice.SoftwareEmulatedSensor: 15>, 'CTRE_MagEncoder_Absolute': <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>, 'CTRE_MagEncoder_Relative': <TalonSRXFeedbackDevice.QuadEncoder: 0>}
    pass
class TalonSRXPIDSetConfiguration(BaseTalonPIDSetConfiguration, BasePIDSetConfiguration):
    """
    Configurables available to TalonSRX's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    pass
class TalonSRXSimCollection():
    """
    Collection of simulation commands available to a TalonSRX motor controller.

    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    """
    def addAnalogPosition(self, dPos: int) -> ErrorCode: 
        """
        Adds to the simulated analog position of the TalonSRX.

        :param dPos: the change in position in native units

        :returns: error code
        """
    def addPulseWidthPosition(self, dPos: int) -> ErrorCode: 
        """
        Adds to the simulated pulse width position of the TalonSRX.

        :param dPos: the change in position in native units

        :returns: error code
        """
    def addQuadraturePosition(self, dPos: int) -> ErrorCode: 
        """
        Adds to the simulated quadrature position of the TalonSRX.

        :param dPos: the change in position in native units

        :returns: error code
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float: 
        """
        Gets the simulated output voltage across M+ and M- for the motor.

        :returns: applied voltage to the motor in volts
        """
    def setAnalogPosition(self, newPos: int) -> ErrorCode: 
        """
        Sets the simulated analog position of the TalonSRX.

        :param newPos: the new position in native units

        :returns: error code
        """
    def setAnalogVelocity(self, newVel: int) -> ErrorCode: 
        """
        Sets the simulated analog velocity of the TalonSRX.

        :param newVel: the new velocity in native units per 100ms

        :returns: error code
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode: 
        """
        Sets the simulated bus voltage of the TalonSRX.

        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.

        :param vbat: the bus voltage in volts

        :returns: error code
        """
    def setLimitFwd(self, isClosed: bool) -> ErrorCode: 
        """
        Sets the simulated forward limit switch of the TalonSRX.

        :param isClosed: true if the limit switch is closed

        :returns: error code
        """
    def setLimitRev(self, isClosed: bool) -> ErrorCode: 
        """
        Sets the simulated reverse limit switch of the TalonSRX.

        :param isClosed: true if the limit switch is closed

        :returns: error code
        """
    def setPulseWidthConnected(self, isConnected: bool) -> ErrorCode: 
        """
        Sets if the simulated pulse width sensor is connected to the TalonSRX.

        :param isConnected: true if the pulse width sensor is connected

        :returns: error code
        """
    def setPulseWidthPosition(self, newPos: int) -> ErrorCode: 
        """
        Sets the simulated pulse width position of the TalonSRX.

        :param newPos: the new position in native units

        :returns: error code
        """
    def setPulseWidthRiseToRiseUs(self, periodUs: float) -> ErrorCode: 
        """
        Sets the simulated pulse width rise to rise time of the TalonSRX.

        :param periodUs: the pulse width rise to rise time in microseconds

        :returns: error code
        """
    def setPulseWidthVelocity(self, newVel: int) -> ErrorCode: 
        """
        Sets the simulated pulse width velocity of the TalonSRX.

        :param newVel: the new velocity in native units per 100ms

        :returns: error code
        """
    def setQuadratureRawPosition(self, newPos: int) -> ErrorCode: 
        """
        Sets the simulated raw quadrature position of the TalonSRX.

        The TalonSRX integrates this to calculate the true reported quadrature
        position.

        When using the WPI Sim GUI, you will notice a readonly 'position' and
        settable 'rawPositionInput'.  The readonly signal is the emulated position
        which will match self-test in Tuner and the hardware API.  Changes to
        'rawPositionInput' will be integrated into the emulated position.  This way
        a simulator can modify the position without overriding your
        hardware API calls for home-ing your sensor.

        Inputs to this function over time should be continuous,
        as user calls of SetSelectedSensorPosition() and SetQuadraturePosition()
        will be accounted for in the calculation.

        :param newPos: the new raw position in native units

        :returns: error code
        """
    def setQuadratureVelocity(self, newVel: int) -> ErrorCode: 
        """
        Sets the simulated quadrature velocity of the TalonSRX.

        :param newVel: the new velocity in native units per 100ms

        :returns: error code
        """
    def setStatorCurrent(self, currA: float) -> ErrorCode: 
        """
        Sets the simulated stator current of the TalonSRX.

        :param currA: the stator current in amps

        :returns: error code
        """
    def setSupplyCurrent(self, currA: float) -> ErrorCode: 
        """
        Sets the simulated supply current of the TalonSRX.

        :param currA: the supply current in amps

        :returns: error code
        """
    pass
class TrajectoryPoint():
    """
    Motion Profile Trajectory Point
    This is simply a data transfer object.
    """
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, position: float, velocity: float, arbFeedFwd: float, auxiliaryPos: float, auxiliaryVel: float, auxiliaryArbFeedFwd: float, profileSlotSelect0: int, profileSlotSelect1: int, isLastPoint: bool, zeroPos: bool, timeDur: int, useAuxPID: bool) -> None: ...
    @property
    def arbFeedFwd(self) -> float:
        """
        Added to the output of PID[0], should be within [-1,+1] where 0.01 = 1%.

        :type: float
        """
    @arbFeedFwd.setter
    def arbFeedFwd(self, arg0: float) -> None:
        """
        Added to the output of PID[0], should be within [-1,+1] where 0.01 = 1%.
        """
    @property
    def auxiliaryArbFeedFwd(self) -> float:
        """
        Added to the output of PID[1], should be within [-1,+1] where 0.01 = 1%.

        :type: float
        """
    @auxiliaryArbFeedFwd.setter
    def auxiliaryArbFeedFwd(self, arg0: float) -> None:
        """
        Added to the output of PID[1], should be within [-1,+1] where 0.01 = 1%.
        """
    @property
    def auxiliaryPos(self) -> float:
        """
        The position for auxiliary PID[1] to target (in sensor units).

        :type: float
        """
    @auxiliaryPos.setter
    def auxiliaryPos(self, arg0: float) -> None:
        """
        The position for auxiliary PID[1] to target (in sensor units).
        """
    @property
    def auxiliaryVel(self) -> float:
        """
        The velocity for auxiliary PID[1] to target. (in sensor-units per 100ms).

        :type: float
        """
    @auxiliaryVel.setter
    def auxiliaryVel(self, arg0: float) -> None:
        """
        The velocity for auxiliary PID[1] to target. (in sensor-units per 100ms).
        """
    @property
    def headingDeg(self) -> float:
        """
        Not used.  Use auxiliaryPos instead.  @see auxiliaryPos

        :type: float
        """
    @headingDeg.setter
    def headingDeg(self, arg0: float) -> None:
        """
        Not used.  Use auxiliaryPos instead.  @see auxiliaryPos
        """
    @property
    def isLastPoint(self) -> bool:
        """
        Set to true to signal Talon that this is the final point, so do not
        attempt to pop another trajectory point from out of the Talon buffer.
        Instead continue processing this way point.  Typically the velocity
        member variable should be zero so that the motor doesn't spin indefinitely.

        :type: bool
        """
    @isLastPoint.setter
    def isLastPoint(self, arg0: bool) -> None:
        """
        Set to true to signal Talon that this is the final point, so do not
        attempt to pop another trajectory point from out of the Talon buffer.
        Instead continue processing this way point.  Typically the velocity
        member variable should be zero so that the motor doesn't spin indefinitely.
        """
    @property
    def position(self) -> float:
        """
        The position to servo to (in sensor units).

        :type: float
        """
    @position.setter
    def position(self, arg0: float) -> None:
        """
        The position to servo to (in sensor units).
        """
    @property
    def profileSlotSelect0(self) -> int:
        """
        Which slot to get PIDF gains.
        PID is used for position servo.
        F is used as the Kv constant for velocity feed-forward.
        Typically this is hard-coded
        to a particular slot, but you are free to gain schedule if need be.
        gain schedule if need be.
        Choose from [0,3].

        :type: int
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        """
        Which slot to get PIDF gains.
        PID is used for position servo.
        F is used as the Kv constant for velocity feed-forward.
        Typically this is hard-coded
        to a particular slot, but you are free to gain schedule if need be.
        gain schedule if need be.
        Choose from [0,3].
        """
    @property
    def profileSlotSelect1(self) -> int:
        """
        Which slot to get PIDF gains for auxiliary PID.
        This only has impact during MotionProfileArc Control mode.
        Choose from [0,3].

        :type: int
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        """
        Which slot to get PIDF gains for auxiliary PID.
        This only has impact during MotionProfileArc Control mode.
        Choose from [0,3].
        """
    @property
    def timeDur(self) -> int:
        """
        :type: int
        """
    @timeDur.setter
    def timeDur(self, arg0: int) -> None:
        pass
    @property
    def useAuxPID(self) -> bool:
        """
        If using MotionProfileArc, this flag must be true on all points.
        If using MotionProfile, this flag must be false on all points.

        :type: bool
        """
    @useAuxPID.setter
    def useAuxPID(self, arg0: bool) -> None:
        """
        If using MotionProfileArc, this flag must be true on all points.
        If using MotionProfile, this flag must be false on all points.
        """
    @property
    def velocity(self) -> float:
        """
        The velocity to feed-forward (in sensor-units per 100ms).

        :type: float
        """
    @velocity.setter
    def velocity(self, arg0: float) -> None:
        """
        The velocity to feed-forward (in sensor-units per 100ms).
        """
    @property
    def zeroPos(self) -> bool:
        """
        Set to true to signal Talon to zero the selected sensor.
        When generating MPs, one simple method is to make the first target position zero,
        and the final target position the target distance from the current position.
        Then when you fire the MP, the current position gets set to zero.
        If this is the intent, you can set zeroPos on the first trajectory point.

        Otherwise you can leave this false for all points, and offset the positions
        of all trajectory points so they are correct.

        If using multiple sensor sources (Arc modes) we recommend you manually set sensor positions
        before arming MP.

        :type: bool
        """
    @zeroPos.setter
    def zeroPos(self, arg0: bool) -> None:
        """
        Set to true to signal Talon to zero the selected sensor.
        When generating MPs, one simple method is to make the first target position zero,
        and the final target position the target distance from the current position.
        Then when you fire the MP, the current position gets set to zero.
        If this is the intent, you can set zeroPos on the first trajectory point.

        Otherwise you can leave this false for all points, and offset the positions
        of all trajectory points so they are correct.

        If using multiple sensor sources (Arc modes) we recommend you manually set sensor positions
        before arming MP.
        """
    pass
class Unmanaged():
    """
    Handles enabling when used in a non-FRC manner
    """
    @staticmethod
    def feedEnable(timeoutMs: int) -> None: 
        """
        Feed the enable frame.
        This function does nothing on a roborio during FRC use.

        If running an application in simulation, creating a WPI\_*
        object automatically enables actuators.
        Otherwise, call this to enable actuators.

        :param timeoutMs: Timeout before disabling
        """
    @staticmethod
    def getEnableState() -> bool: 
        """
        :returns: true if enabled
        """
    @staticmethod
    def getPhoenixVersion() -> int: 
        """
        :returns: Phoenix version
        """
    @staticmethod
    def loadPhoenix() -> None: 
        """
        Calling this function will load and start
        the Phoenix background tasks.

        This can be useful if you need the
        Enable/Disable functionality for CAN devices
        but aren't using any of the CAN device classes.

        This function does NOT need to be called if
        you are using any of the Phoenix CAN device classes.
        """
    @staticmethod
    def setPhoenixDiagnosticsStartTime(startTimeSeconds: int) -> None: 
        """
        Sets the duration of the delay before starting
        the Phoenix diagnostics server.

        :param startTime: Magnitude of the delay (in seconds) before
                          starting the server.
                          A value of 0 will start the server immediately.
                          A negative value will signal the server
                          to shutdown or never start.
        """
    pass
class VelocityMeasPeriod():
    """
    Velocity Measurement Periods

    Members:

      Period_1Ms : 1ms measurement period

      Period_2Ms : 2ms measurement period

      Period_5Ms : 5ms measurement period

      Period_10Ms : 10ms measurement period

      Period_20Ms : 20ms measurement period

      Period_25Ms : 25ms measurement period

      Period_50Ms : 50ms measurement period

      Period_100Ms : 100ms measurement period
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Period_100Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_100Ms: 100>
    Period_10Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_10Ms: 10>
    Period_1Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_1Ms: 1>
    Period_20Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_20Ms: 20>
    Period_25Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_25Ms: 25>
    Period_2Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_2Ms: 2>
    Period_50Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_50Ms: 50>
    Period_5Ms: ctre._ctre.VelocityMeasPeriod # value = <VelocityMeasPeriod.Period_5Ms: 5>
    __members__: dict # value = {'Period_1Ms': <VelocityMeasPeriod.Period_1Ms: 1>, 'Period_2Ms': <VelocityMeasPeriod.Period_2Ms: 2>, 'Period_5Ms': <VelocityMeasPeriod.Period_5Ms: 5>, 'Period_10Ms': <VelocityMeasPeriod.Period_10Ms: 10>, 'Period_20Ms': <VelocityMeasPeriod.Period_20Ms: 20>, 'Period_25Ms': <VelocityMeasPeriod.Period_25Ms: 25>, 'Period_50Ms': <VelocityMeasPeriod.Period_50Ms: 50>, 'Period_100Ms': <VelocityMeasPeriod.Period_100Ms: 100>}
    pass
class VictorConfigUtil():
    """
    Util class to help with VictorSPX configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def diff0TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def diff1TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def sum0TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def sum1TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    pass
class VictorSPX(BaseMotorController, IMotorController, IFollower):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.

    ::

      {@code
      // Example usage of a VictorSPX motor controller
      VictorSPX motor{0}; // creates a new VictorSPX with ID 0
      
      motor.Set(VictorSPXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetBusVoltage() << std::endl; // prints the bus voltage seen by the motor controller
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      }

    .. seealso::
       :class:`WPI_VictorSPX`
    """
    @typing.overload
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor

        :param deviceNumber: [0,62]

        Constructor so non-FRC platforms can specify a CAN 2.0 socketcan bus

        :param deviceNumber: CAN Device ID of VictorSPX
        :param canbus:       String specifying the bus
        """
    @typing.overload
    def __init__(self, deviceNumber: int, canbus: str) -> None: ...
    def configAllSettings(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getAllConfigs(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: VictorSPXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSimCollection(self) -> VictorSPXSimCollection: 
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the motor controller, depending on the mode.

        *       Standard Driving Example:
        *       victorLeft.set(ControlMode.PercentOutput, leftJoy);
        *       victorRght.set(ControlMode.PercentOutput, rghtJoy);

        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the motor controller to
                      duplicate.
        :param value: The setpoint value, as described above.

        Arcade Drive Example:
        *               _victorLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
        *               _victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
        *               _victorRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the motor controller, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the motor controller to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None: ...
    pass
class VictorSPXConfiguration(BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to VictorSPX
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @property
    def auxiliaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Auxiliary PID configuration

        :type: VictorSPXPIDSetConfiguration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        """
        Auxiliary PID configuration
        """
    @property
    def diff0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 0 Term

        :type: RemoteFeedbackDevice
        """
    @diff0Term.setter
    def diff0Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Diff 0 Term
        """
    @property
    def diff1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 1 Term

        :type: RemoteFeedbackDevice
        """
    @diff1Term.setter
    def diff1Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Diff 1 Term
        """
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Forward limit switch normally open/closed
        """
    @property
    def forwardLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: RemoteLimitSwitchSource
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def primaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Primary PID configuration

        :type: VictorSPXPIDSetConfiguration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        """
        Primary PID configuration
        """
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Reverse limit switch normally open/closed
        """
    @property
    def reverseLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: RemoteLimitSwitchSource
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def sum0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 0 Term

        :type: RemoteFeedbackDevice
        """
    @sum0Term.setter
    def sum0Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Sum 0 Term
        """
    @property
    def sum1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 1 Term

        :type: RemoteFeedbackDevice
        """
    @sum1Term.setter
    def sum1Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Sum 1 Term
        """
    pass
class VictorSPXControlMode():
    """
    Choose the control mode for a Victor SPX.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      Disabled : Disable Motor Controller
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    Disabled: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.Disabled: 15>
    Follower: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.Follower: 5>
    MotionMagic: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.MotionMagic: 7>
    MotionProfile: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.MotionProfile: 6>
    MotionProfileArc: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.MotionProfileArc: 10>
    PercentOutput: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.PercentOutput: 0>
    Position: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.Position: 1>
    Velocity: ctre._ctre.VictorSPXControlMode # value = <VictorSPXControlMode.Velocity: 2>
    __members__: dict # value = {'PercentOutput': <VictorSPXControlMode.PercentOutput: 0>, 'Position': <VictorSPXControlMode.Position: 1>, 'Velocity': <VictorSPXControlMode.Velocity: 2>, 'Follower': <VictorSPXControlMode.Follower: 5>, 'MotionProfile': <VictorSPXControlMode.MotionProfile: 6>, 'MotionMagic': <VictorSPXControlMode.MotionMagic: 7>, 'MotionProfileArc': <VictorSPXControlMode.MotionProfileArc: 10>, 'Disabled': <VictorSPXControlMode.Disabled: 15>}
    pass
class VictorSPXPIDSetConfigUtil():
    """
    Util class to help with VictorSPX's PID configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: VictorSPXPIDSetConfiguration) -> bool: ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: VictorSPXPIDSetConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class VictorSPXPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to VictorSPX's PID
    """
    def __init__(self) -> None: ...
    def __str__(self) -> str: 
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str: 
        """
        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @property
    def selectedFeedbackSensor(self) -> RemoteFeedbackDevice:
        """
        Feedback device for a particular PID loop.

        :type: RemoteFeedbackDevice
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback device for a particular PID loop.
        """
    pass
class VictorSPXSimCollection():
    """
    Collection of simulation commands available to a VictorSPX motor controller.

    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float: 
        """
        Gets the simulated output voltage across M+ and M- for the motor.

        :returns: applied voltage to the motor in volts
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode: 
        """
        Sets the simulated bus voltage of the VictorSPX.

        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.

        :param vbat: the bus voltage in volts

        :returns: error code
        """
    pass
class WPI_BaseMotorController(BaseMotorController, IMotorController, IFollower, wpilib.interfaces._interfaces.MotorController, wpilib._wpilib.MotorSafety, wpiutil._wpiutil.Sendable):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def disable(self) -> None: 
        """
        Common interface for disabling a motor.
        """
    def get(self) -> float: 
        """
        Common interface for getting the current set speed of a speed controller.

        :returns: The current set speed.  Value is between -1.0 and 1.0.
        """
    def getDescription(self) -> str: 
        """
        :returns: description of controller
        """
    def getInverted(self) -> bool: 
        """
        Common interface for returning the inversion state of a speed controller.

        :returns: isInverted The state of inversion, true is inverted.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Common interface for setting the speed of a simple speed controller.

        :param speed: The speed to set.  Value should be between -1.0 and 1.0.
                      Value is also saved for Get().

        Sets the appropriate output on the talon, depending on the mode.

        *       Standard Driving Example:
        *       _talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *       _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.

        Arcade Drive Example:
        *               _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

        *       Drive Straight Example:
        *       Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

        *       Drive Straight to a Distance Example:
        *       Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *               _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *               _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);

        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *    demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.  Units match the set mode.
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, speed: float) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: 
        """
        Common interface for inverting direction of a speed controller.

        :param isInverted: The state of inversion, true is inverted.

        Common interface for inverting direction of a speed controller.

        :param invertType: The invert strategy to use. Follower controllers
                           that mirror/oppose the master controller should
                           *                                    use this method.
        """
    @typing.overload
    def setInverted(self, isInverted: bool) -> None: ...
    def setVoltage(self, output: volts) -> None: 
        """
        Sets the voltage output of the SpeedController.  Compensates for
        the current bus voltage to ensure that the desired voltage is output even
        if the battery voltage is below 12V - highly useful when the voltage
        outputs are "meaningful" (e.g. they come from a feedforward calculation).

        NOTE: This function *must* be called regularly in order for voltage
        compensation to work properly - unlike the ordinary set function, it is not
        "set it and forget it."

        :param output: The voltage to output.
        """
    def stopMotor(self) -> None: 
        """
        Common interface to stop the motor until Set is called again.
        """
    pass
class WPI_TalonFX(TalonFX, BaseTalon, WPI_BaseMotorController, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower, wpilib.interfaces._interfaces.MotorController, wpilib._wpilib.MotorSafety, wpiutil._wpiutil.Sendable):
    """
    CTRE Talon FX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int, canbus: str = '') -> None: 
        """
        Constructor for a WPI_TalonFX

        :param deviceNumber: Device ID of TalonFX
        :param canbus:       Name of the CANbus; can be a CANivore device name or serial number.
                             Pass in nothing or "rio" to use the roboRIO.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
class WPI_TalonSRX(TalonSRX, BaseTalon, WPI_BaseMotorController, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower, wpilib.interfaces._interfaces.MotorController, wpilib._wpilib.MotorSafety, wpiutil._wpiutil.Sendable):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a WPI_TalonSRX

        :param deviceNumber: Device ID of TalonSRX
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
class WPI_VictorSPX(VictorSPX, WPI_BaseMotorController, BaseMotorController, IMotorController, IFollower, wpilib.interfaces._interfaces.MotorController, wpilib._wpilib.MotorSafety, wpiutil._wpiutil.Sendable):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a WPI_VictorSPX

        :param deviceNumber: Device ID of VictorSPX
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
